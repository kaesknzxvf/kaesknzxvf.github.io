[ { "title": "Flutter 01 Simple Chat UI 응용 03 데이터 로컬 저장 및 읽기,쓰기_메세지 로그편 ", "url": "/posts/Flutter-Simple-Chat-UI-EX03/", "categories": "Flutter, Simple Chat", "tags": "flutter, practice, programming", "date": "2022-09-19 20:17:00 +0900", "snippet": "이 포스트는 How to Build a Chat App UI With Flutter and Dart을 따라서 작성한 Flutter Simple Chat UI 을 응용하여 좀 더 그럴듯한 채팅앱을 구현하기 위한 과정을 다룬다.주요 내용은 이하와 같다. ChatDetailPage : 유저 별 메세지 로그 저장, 불러오기 코드 정리 : 메세지 로그 리스트뷰 코드 분리 메세지 로그 저장/불러오기 시의 주의 점 해당 유저의 메세지 로그 불러오기 메세지 로그 저장 UI 변경, 기능 추가 (옵션) 받은 메세지 조작 : receiver 버튼, 기능 추가 메세지 초기화 : clear 버튼, 기능 추가 개별 메세지에 대한 기능 추가 (개별 메세지 복사, 수정, 삭제) ChatPage : 유저 데이터 갱신 각 유저의 최근 메세지 표시 원문의 예제는 단순히 UI만 다루는 포스트이다 보니, 실제로 데이터를 전달하거나 저장하는 등 데이터를 처리하는 작업은 해주지 않는다. 그러므로 이번 포스트는 스스로 공부하며 추가한 코드이다.관련 포스트 Base, Chat 화면 구현 Chat Detail 화면 구현 응용 01 (Chat Detail 화면) 화면 간 데이터 전달, 메세지 입력 응용 02 데이터 로컬 저장 및 읽기,쓰기_유저정보편 (+상태창 추가) 응용 03 데이터 로컬 저장 및 읽기,쓰기_메세지로그편 (현재포스트)환경 MacBook Air (M1, 2020) macOS Monterey (v12.4) Flutter 3.0.3 Dart 2.17.5 Visual Studio Code 1.69.0ChatDetailPage : 유저 별 메세지 로그 저장, 불러오기먼저 유저 별 메세지 로그를 저장하고, 기타 기능을 구현하기 위해서 ChatMessage 모델의 속성을 조금 추가해 주었다. userid : 현재 채팅을 하고있는 유저의 id속성을 받는 속성 messageid : 개별 메세지의 식별을 위한 속성, ChatUsers 모델의 id와 마찬가지로 uuid플러그인을 이용해 생성자 실행 시에 자동으로 할당되도록 해주었다.import 'package:hive/hive.dart'; import 'package:uuid/uuid.dart';part 'chatMessageModel.g.dart';var uuid = Uuid();@HiveType(typeId: 2)class ChatMessage { @HiveField(0) //추가 String userid; //추가 @HiveField(1) //추가 String messageid; //추가 @HiveField(2) String messageContent; @HiveField(3) String messageType; ChatMessage( {required this.userid, String? messageid, required this.messageContent, required this.messageType}) : messageid = messageid ?? uuid.v4();}수정 후에는 TypeAdapter 갱신해주는 걸 잊지 말자flutter packages pub run build_runner build코드 정리 : 메세지 로그 리스트뷰 코드 분리지금 ChatDetailPage.dart 화면에 UI랑 데이터 처리 코드가 섞여 너무 정신사나워서, 메세지 로그를 표시하는 리스트뷰 부분 코드를 조금 정리했다.chatPage.dart의 유저 목록을 표시하는 리스트뷰 conversationList.dart를 분리한 것 처럼, ChatDetailPage.dart도 body에 메세지로그를 표시하는 Listview를 messageList.dart 라는 widget으로 분리했다.import 'package:flutter/material.dart';class MessageList extends StatefulWidget { String userid; ChatMessage currentmsg; MessageList( {required this.userid, required this.currentmsg}); @override _MessageListState createState() =&gt; _MessageListState();}class _MessageListState extends State&lt;MessageList&gt; { @override Widget build(BuildContext context) { return Container( padding: EdgeInsets.only(left: 16, right: 16, top: 10, bottom: 10), child: Align( alignment: (widget.currentmsg.messageType == \"receiver\" ? Alignment.topLeft : Alignment.topRight), child: Container( decoration: BoxDecoration( borderRadius: BorderRadius.circular(20), color: (widget.currentmsg.messageType == \"receiver\" ? Colors.grey.shade200 : Colors.blue[200]), ), padding: EdgeInsets.all(16), margin: (widget.currentmsg.messageType == \"receiver\" ? EdgeInsets.only(left: 0, right: 64, top: 0, bottom: 0) : EdgeInsets.only(left: 64, right: 0, top: 0, bottom: 0)), child: Text(¥ widget.currentmsg.messageContent, style: TextStyle(fontSize: 15), ), ), ), ); }}기존 파일에서는 해당 부분 삭제하고 인수 전달만 해주었다.//추가import 'package:flt_simple_chat_ex/widgets/messageList.dart';... // 생략 body: Column( children: &lt;Widget&gt;[ Flexible( fit: FlexFit.tight, child: SingleChildScrollView( physics: BouncingScrollPhysics(), controller: _scrollController, child: ListView.builder( itemCount: _mstate_currentuser.length, shrinkWrap: true, padding: EdgeInsets.only( top: 10), physics: NeverScrollableScrollPhysics(), itemBuilder: (context, index) { // 수정, 인수로 전달 return MessageList( userid: widget.cpuser.id, currentmsg: ChatMessage( userid: widget.cpuser.id, messageid: _mstate_currentuser[index].messageid, messageContent: _mstate_currentuser[index].messageContent, messageType: _mstate_currentuser[index].messageType), ); // 수정, 인수로 전달 }, ), ), ),... // 생략이제 메세지 로그에 대한 처리는 messageList.dart에서 할 것이다.메세지 로그 저장/불러오기 시의 주의 점코드도 정리했고 사용할 기능도 대충 만들었으니 이제 본격적으로 메세지를 저장해보자. 근데 사실… 유저 리스트 저장하는 것과 별 다를 것 없다. (이전 포스팅에서 provider에 대한 걸 다뤘으니 당연히 /providers/messages.dart가 있고, TypeAdapter가 등록, 범위 지정이 되어있다고 가정한다.) 메세지 로그를 담은 박스의 이름은 'message_log'인데, provider에서 이 박스를 요리 다루고 조리 다루면 된다.메세지에 대한 읽기 및 쓰기 작업이 이루어 지는 위젯은 주로 chatDetailPage.dart과 messageList.dart일텐데, 필요에 따라import 'package:flt_simple_chat_ex/providers/messages.dart';import 'package:provider/provider.dart';... // 생략 @override Widget build(BuildContext context) { final _mstate = context.watch&lt;MessageListPrState&gt;().messages; final _mctlr = context.read&lt;MessageListController&gt;();... // 생략이런 식으로 provider에 접근해서 메세지를 읽고 써주면 된다.단, 지금 구현한 코드에서 유저 목록을 다룰 때와는 다르게 반드시 고려해야 할 점이 있는데, 바로 유저 목록('user_log'박스)은 그 박스 자체로 하나의 개체로 볼 수 있지만, 메세지 로그('message_log'박스)의 경우 모든 유저의 메세지를 구별없이 전부 담고 있는 하나의 혼돈의 박스라는 점이다. 그러니까 각 유저의 채팅 창에는 'message_log'에 있는 모든 메세지를 전부 출력할게 아니라 그 채팅 창의 유저가 누군지 확인해서 해당 유저와 관련된 메세지만을 표시해야 된다는 소리다. 이걸 위해 ChatMessage 모델에 userid 속성을 추가한 것이다. (나도… 아주 이상한 코드라는 건 안다… 알긴 아는데 능력 부족으로 일단 밀고 나갔다)개판 5분 전이지만 일단 가보자고…해당 유저의 메세지 로그 불러오기채팅창을 열었을 때, checkUserMsg(widget.cpuser.id) 라는 함수를 사용하여 리스트뷰를 빌드했다.messages provider의 MessageListPrState에 checkUserMsg라는 함수를 만들어서 현재 열어둔 채팅창의 userid를 가진 메세지들만으로만 구성된 리스트를 반환하도록 해주었다. (MessageListPrState에 구현한 이유는, 딱히 데이터베이스에 항목을 추가하거나 삭제하는게 아니고 단지 선별해서 읽어올 뿐이기 때문)... // 생략 final _mstate_currentuser = context.watch&lt;MessageListPrState&gt;().checkUserMsg(widget.cpuser.id);... // 생략 body: Column( children: &lt;Widget&gt;[ Flexible( fit: FlexFit.tight, child: SingleChildScrollView( physics: BouncingScrollPhysics(), controller: _scrollController, child: ListView.builder( itemCount: _mstate_currentuser.length, // 수정 shrinkWrap: true, padding: EdgeInsets.only( top: 10), physics: NeverScrollableScrollPhysics(), itemBuilder: (context, index) { return MessageList( userid: widget.cpuser.id, currentmsg: ChatMessage( userid: widget.cpuser.id, messageid: _mstate_currentuser[index].messageid, // 수정 messageContent: _mstate_currentuser[index].messageContent, // 수정 messageType: _mstate_currentuser[index].messageType), // 수정 ); }, ), ), ), // Flexible... // 생략checkUserMsg()는 이렇게 생겼다.... // 생략class MessageListPrState {... // 생략 List&lt;ChatMessage&gt; checkUserMsg(String userid) { List&lt;ChatMessage&gt; usermsg = []; for (int i = 0; i &lt; messages.length; i++) { if (messages[i].userid == userid) { usermsg.insert(usermsg.length, messages[i]); } } return usermsg; }... // 생략이렇게하면 최적화는 개나 준 코드 완성!유저가 생길 때마다 메세지 박스를 열어 준 다음, ChatDetailPage에 접근하면 그 박스를 던져주고 연산 없이 읽고 쓸 수 있게 해줘야 한다… 는 걸 머리로는 알고 있지만, 그냥 코드가 생겨 먹은 대로 쓰려고 짱구를 굴리다 보니 이런 요오상한 코드가 탄생했다.사실 그렇게 해주려고 이것저것 찾아보고 provider안에서 openBox해주도록 짜봤는데, provider의 Scope를 거의 최상위 위젯으로 두고 있어서, openBox하는 타이밍이 main()이 아니면 에러가… ㅎ…원하는 기능이 그럴 듯하게 구현이 되기는 했지만, 이건 너무 눈가리고 아웅하는 식이라 hive를 좀 더 동적으로 다룰 수 있는 방법이 있나 찾아보고, 시도해 볼 예정이다. 나의 실력에 RIP,,,메세지 로그 저장ChatDetailPage에서 send 버튼을 누를 때, addMessage(newMsg) 라는 함수를 실행... // 생략 SizedBox( height: 30, width: 50, child: FloatingActionButton( heroTag: \"btn_send\", onPressed: () { if (msgtextController.text.isNotEmpty) { ChatMessage newMsg = ChatMessage( userid: widget.cpuser.id, messageContent: msgtextController.text, messageType: \"sender\"); debugPrint('Input text : ${newMsg.messageContent}'); setState(() { _mctlr.addMessage(newMsg); // 추가 msgtextController.clear(); latest_msg = msgtextController.text; }); _scrollToLatest(); } }, child: Icon( Icons.send, color: Colors.white, size: 18, ), backgroundColor: Colors.blue, elevation: 0, ), ),... // 생략messages provider MessageListController의 addMessage함수는 이렇게 생겼다. (이건 그냥 addUser와 똑같이 생겼음)... // 생략 void addMessage(ChatMessage message) { final _messages = [...state.messages, message]; state = state.copyWith(messages: _messages); messageList!.put(message.messageid, message); }... // 생략기본적인 읽기, 쓰기기는 이렇다. 여기까지 했으면, (비록 효율적이지는 않지만) 유저 별로 메세지의 저장이 가능한 기본적인 기능을 하는 것처럼 보이는 채팅앱이 완성된다.(데모에서는 ChatPage로 돌아갔을 때, 유저 이름 밑에 유저와의 마지막 메세지가 표시되도록 하고 있는데, 이에 대해서는 이 포스팅 마지막 장에 기술)UI 변경, 기능 추가 (옵션)이번 장은 그냥 나 편하자고 이하의 UI 변경, 기능 추가를 한 내용이다. 받은 메세지 조작 : receiver 버튼, 기능 추가 메세지 초기화 : clear 버튼, 기능 추가 개별 메세지에 대한 기능 추가 (개별 메세지 복사, 수정, 삭제)받은 메세지 조작 : receiver 버튼, 기능 추가원래는 내가 보내는 버튼만 있는게 맞지만, 여기서는 그럴듯하게 채팅창을 모방하기 위해 내가 받는 메세지도 조작할 수 있도록 send버튼 왼쪽 옆에 receive버튼을 하나 더 추가해 주었다. 텍스트 필드에 글을 입력하고 receive버튼을 누르면 해당 메세지가 나에게 온 메세지처럼 표시하는 기능을 한다.기본적으로는 send버튼의 포멧을 그대로 사용하고, 전달하는 messageType을 receiver 해주면 된다. (+ Icon 변경)... // 생략 SizedBox( height: 30, width: 50, child: FloatingActionButton( heroTag: \"btn_receive\", //heroTag 중복에러 방지 (heroTag: null도 가능) onPressed: () { if (msgtextController.text.isNotEmpty) { ChatMessage newMsg = ChatMessage( userid: widget.cpuser.id, messageContent: msgtextController.text, messageType: \"receiver\"); //수정 setState(() { _mctlr.addMessage(newMsg); msgtextController .clear(); latest_msg = msgtextController.text; }); _scrollToLatest(); } }, child: Icon( Icons.send_outlined, color: Colors.white, size: 18, ), backgroundColor: Colors.blue, elevation: 0, ), ),... // 생략만약 receiver버튼 추가하고 이런 에러가 난다면,════════ Exception caught by scheduler library ═════════════════════════════════The following assertion was thrown during a scheduler callback:There are multiple heroes that share the same tag within a subtree.Within each subtree for which heroes are to be animated (i.e. a PageRoute subtree), each Hero must have a unique non-null tag.In this case, multiple heroes had the following tag: &lt;default FloatingActionButton tag&gt;Here is the subtree for one of the offending heroes: Hero tag: &lt;default FloatingActionButton tag&gt; state: _HeroState#a0c4cheroTag를 설정하지 않은 FloatingActionButton이 같은 위젯에 여러개 있어서 그런 것이니, 각 FloatingActionButton위젯에 herotag를 설정해 주자. (모든 FloatingActionButton에 heroTag: null이라고 해줘도 되긴 됨)결과, 이러한 UI 된다. 왼쪽 버튼을 누르면 내가 받은 메세지가 되고, 오른쪽 버튼을 누르면 내가 보낸 메세지가 된다.메세지 초기화 : clear 버튼, 기능 추가ChatPage의 유저 목록 Clear와 마찬가지로 AppBar에 메세지 로그의 모든 메세지을 지우는 버튼을 추가했다. (+덤으로 설정 버튼이 그냥 Icon으로만 되어있길래 누를 수 있도록 IconButton으로 변경해 주었음, 기능은 추가X)... // 생략 final _mctlr = context.read&lt;MessageListController&gt;();... // 생략 IconButton( // 메세지 로그 Clear onPressed: () { print(\"Click Clear Button\"); _mctlr.clearUserMsg(widget.cpuser.id); //추가 }, alignment: Alignment.centerRight, icon: const Icon( Icons.clear_all, color: Colors.black, ), ), IconButton( // Setting onPressed: () { print(\"Click Setting Button\"); }, alignment: Alignment.centerRight, icon: const Icon( Icons.settings, color: Colors.black54, ), ),... // 생략추가 후의 UI는 이런 모습.기능 구현을 위해서 message provider(/providers/messages.dart)의 MessageListController에 clearUserMsg 라는 함수를 추가해 주었다. 동작방식은 userid를 인수로 받아, 기존의 메세지 리스트(messages)에서 userid를 가진 메세지를 솎아낸 메세지 리스트를 만들어(_messages), 기존의 메세지 리스트(messages)를 해당 메세지 리스트(_messages)로 교체하는 것이다. hive box에서의 삭제는 좀 더 쉽다. .delete함수를 사용하여 userid를 가진 개체를 지워주면 된다.... // 생략 void clearUserMsg(String userid) { final _messages = state.messages.where((m) =&gt; m.userid != userid).toList(); state = state.copyWith(messages: _messages); messageList!.delete(userid); }... // 생략위의 두 기능에 대한 데모. 잘 구현되었다는 걸 확인할 수 있다.개별 메세지에 대한 기능 추가 (개별 메세지 복사, 수정, 삭제)개별 메세지를 롱터치하면 메뉴가 나오고, 메뉴를 통해 해당 메세지를 복사, 수정, 삭제가 가능하도록 기능을 추가했다.메세지를 롱터치 했을 때, 메뉴가 나오게 하는 방법은 Flutter: Showing a Context Menu on Long Press와 stackoverflow의 코드를 참고했다.사실 두 사이트에 있는 솔루션 그대로 코드를 작성하면 내가 원하는 대로 움직이지를 않길래 (메뉴 박스가 롱터치한 위치에서 제대로 나오지 않고 x축 또는 y축이 고정되어있었음.. 반쪽짜리 기능 됨) 입맛대로 고쳐서 원하는 대로 움직이게 만들긴 했는데, 얼레벌레 성공해 버려서 솔직히 RelativeRect 클래스의 동작 방식을 아직 완전히 이해하지는 못했다. 두 사각형을 그려서 상대적인 위치를 계산해 박스를 출력하는것 같긴한데… 나중에 문서 좀 제대로 읽어봐야 겠다. 일단 내가 작성한 얼레벌레 코드는 이렇다.... // 생략class _MessageListState extends State&lt;MessageList&gt; {... // 생략 Offset _tapPosition = Offset.zero; void _getTapPosition(TapDownDetails details) { print(\"on Tap Down\"); final RenderBox referenceBox = context.findRenderObject() as RenderBox; setState(() { _tapPosition = referenceBox.globalToLocal(details.globalPosition); }); } final widgetKey = GlobalKey(); RelativeRect _getRelativeRect(GlobalKey key) { return RelativeRect.fromSize( _getWidgetGlobalRect(key), const Size(10000, 200)); } Rect _getWidgetGlobalRect(GlobalKey key) { final RenderBox renderBox = key.currentContext!.findRenderObject() as RenderBox; var offset = renderBox.localToGlobal(Offset.zero); final RenderObject? overlay = Overlay.of(context)?.context.findRenderObject(); return Rect.fromLTWH(_tapPosition.dx, offset.dy, renderBox.size.width, renderBox.size.height); } void _showContextMenu(BuildContext context, GlobalKey key) async { final _mctlr = context.read&lt;MessageListController&gt;(); // 동작 제어를 위해 미리 추가 final result = await showMenu( context: context, position: _getRelativeRect(key), items: [ const PopupMenuItem( value: 'copy', child: Text('Copy Text'), ), const PopupMenuItem( value: 'edit', child: Text('Edit Text'), ), const PopupMenuItem( value: 'delete', child: Text('Delete Text'), ), ]); switch (result) { case 'copy': debugPrint('Copy Text'); // 복사 동작 추가 부분 break; case 'edit': debugPrint('Edit Text'); // 수정 동작 추가 부분 break; case 'delete': debugPrint('Delete Text'); // 삭제 동작 추가 부분 break; } } @override Widget build(BuildContext context) { return GestureDetector( // 추가 key: widgetKey, onTapDown: (details) { _getTapPosition(details); }, onLongPress: () { _showContextMenu(context, widgetKey); }, // 추가 END child: Container(... // 생략복사services.dart 라는 패키지의 Clipboard.setData()라는 함수를 통해서 쉽게 구현할 수 있다.... // 생략import 'package:flutter/services.dart'; // 추가... // 생략 void _showContextMenu(BuildContext context) async {... // 생략 switch (result) { case 'copy': debugPrint('Copy Text'); Clipboard.setData(ClipboardData(text: widget.currentmsg.messageContent)); // 추가 break;... // 생략수정먼저 message provider MessageListController에 editMessage()라는 함수를 작성해 주었다. 버튼이 눌리면 텍스트를 수정할 수 있는 팝업을 실행(InputDialog), 팝업창에서 텍스트의 수정이 발생한 경우, editMessage()함수를 실행해 주었다.... // 생략 void _showContextMenu(BuildContext context) async { final _mctlr = context.read&lt;MessageListController&gt;();... // 생략 switch (result) {... // 생략 case 'edit': debugPrint('Edit Text'); String? inputtext = await InputDialog(context); _textFieldController.clear(); if (inputtext == \"\" || inputtext == null || inputtext == widget.currentmsg.messageContent) { print(\"Text not changed!\"); } else { String edittext = inputtext; _mctlr.editMessage(widget.currentmsg, edittext); setState(() { widget.currentmsg.messageContent = edittext; //화면에서도 곧 바로 수정 }); } break;... // 생략InputDialog()함수는 별다를 것 없이 생겼는데, 이번에는 기존의 텍스트를 수정하는 거니까 텍스트 필드에 기존에 메세지 내용이 디폴트로 들어가 있고 그것을 수정하도록 TextEditingController의 포멧을 조금 변경해 주었다.... // 생략class _MessageListState extends State&lt;MessageList&gt; { late TextEditingController _textFieldController; @override void initState() { super.initState(); _textFieldController = TextEditingController( text: widget.currentmsg.messageContent); // 기존 텍스트가 텍스트필드의 초기값 } Future&lt;String?&gt; InputDialog(BuildContext context) async { final ButtonStyle flatButtonStyle = TextButton.styleFrom( backgroundColor: Color.fromARGB(255, 100, 100, 9100), padding: EdgeInsets.all(0), ); _textFieldController = TextEditingController( text: widget.currentmsg.messageContent); // 기존 텍스트가 텍스트필드의 초기값 return showDialog( context: context, builder: (context) { return AlertDialog( title: Text('메세지 수정'), content: TextField( controller: _textFieldController, decoration: InputDecoration(hintText: widget.currentmsg.messageContent), ), actions: &lt;Widget&gt;[ ElevatedButton( child: const Text(\"취소\"), onPressed: () =&gt; Navigator.pop(context), ), ElevatedButton( child: const Text('완료'), onPressed: () =&gt; Navigator.pop(context, _textFieldController.text), ), ], ); }); }... // 생략editMessage()에서는 messageid속성을 이용하여 해당 메세지를 식별하여 해당 메세지의 messageContent를 입력 받은 텍스트로 수정한다.... // 생략class MessageListController extends StateNotifier&lt;MessageListPrState&gt; {... // 생략 void editMessage(ChatMessage message, String edittext) { for (int index = 0; index &lt; [...state.messages].length; index++) { if ([...state.messages][index].messageid == message.messageid) { [...state.messages][index].messageContent = edittext; messageList!.put( message.messageid, ChatMessage( userid: message.userid, messageid: message.messageid, messageContent: edittext, messageType: message.messageType)); break; } else { continue; } } }... // 생략삭제message provider MessageListController에 deleteMessage()라는 함수를 작성해 주고, 버튼이 눌리면 함수를 실행해 주었다.... // 생략 void _showContextMenu(BuildContext context) async { final _mctlr = context.read&lt;MessageListController&gt;();... // 생략 switch (result) {... // 생략 case 'delete': debugPrint('Delete Text'); _mctlr.deleteMessage(widget.currentmsg); break;... // 생략deleteMessage()에서는 messageid속성을 이용하여 해당 메세지만 배제한 메세지 리스트를 만들어낸다.... // 생략class MessageListController extends StateNotifier&lt;MessageListPrState&gt; {... // 생략 void deleteMessage(ChatMessage message) { final _messages = state.messages.where((m) =&gt; m.messageid != message.messageid).toList(); state = state.copyWith(messages: _messages); messageList!.delete(message.userid); }... // 생략이 기능들의 실행 데모는 다음과 같다.ChatPage : 유저 데이터 갱신각 유저의 최근 메세지 표시이렇게 유저별 채팅 데이터를 저장해 주면, ChatPage화면에 출력 되는 각 유저의 최근메세지를 갱신하는 의미가 생긴다. 유저 리스트 UI를 표시하는 conversationList.dart에서 유저 이름 밑에 표시하는 텍스트를 수정하면 된다.... // 생략 Widget build(BuildContext context) { // 추가 final _mstate_currentuser_len = context.watch&lt;MessageListPrState&gt;().checkUserMsg(widget.user.id).length; bool msgtext_null = _mstate_currentuser_len == 0; widget.user.messageText = msgtext_null ? \" \" : _mstate_currentuser[_mstate_currentuser_len - 1].messageContent; // 추가 END return GestureDetector( onTap: () async { await Navigator.of(context).push(MaterialPageRoute( builder: (context) { return ChatDetailPage( cpuser: widget.user, ); }, )); // 추가 if (mounted) { setState(() { }); } // 추가 END }, child: Container( padding: EdgeInsets.only(left: 16, right: 16, top: 10, bottom: 10), child: Row( children: &lt;Widget&gt;[ Expanded( child: Row( children: &lt;Widget&gt;[ InkWell( ... // 생략 ), Expanded( child: Container( color: Colors.transparent, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Text( widget.user.name, style: TextStyle(fontSize: 16), ), SizedBox( height: 6, ), Text( widget.user.messageText, // &lt;- 여기에 나타다는 글씨를 수정 style: TextStyle( fontSize: 13, color: Colors.grey.shade600, fontWeight: widget.isMessageRead ? FontWeight.bold : FontWeight.normal), ), ], ), ), ),... // 생략msgtext_null을 이용한 연산을 굳이 추가한 이유는, 유저를 생성했을 때 예외 처리가 필요하기 때문이다. 유저를 생성한 직 후라면 당연하지만 해당 유저와 관련된 메세지는 없을 것이다. 그러므로 해당 유저에 대한 메세지가 없을 때는, \" \"를 넣어 주어서 아무 것도 입력되지 않은 것 처럼 보여주도록 코드를 작성했다. 메세지가 있을 때는, 해당 유저와 나눈 메세지 리스트 중 가장 마지막에 있는 항목을 가져오도록 하면된다.또한,ChatDetailPage에서 마지막 메세지가 수정된 경우에는 conversationList 위젯도 상태 갱신을 해주어야하기 때문에, onTap{} 에 setState()를 추가해 주었다. if (mounted) {} 조건문을 건 이유상태 갱신을 위해서 setState()만을 추가해 주면, 이런 에러가 뜬다.[VERBOSE-2:ui_dart_state.cc(198)] Unhandled Exception: setState() called after dispose(): _ConversationListState#8ffd2(lifecycle state: defunct, not mounted)This error happens if you call setState() on a State object for a widget that no longer appears in the widget tree (e.g., whose parent widget no longer includes the widget in its build). This error can occur when code calls setState() from a timer or an animation callback.The preferred solution is to cancel the timer or stop listening to the animation in the dispose() callback. Another solution is to check the \"mounted\" property of this object before calling setState() to ensure the object is still in the tree.This error might indicate a memory leak if setState() is being called because another object is retaining a reference to this State object after it has been removed from the tree. To avoid memory leaks, consider breaking the reference to this object during dispose().#0 State.setState.&lt;anonymous closure&gt; (package:flutter/src/widgets&lt;…&gt;내용을 보면 아마 onTap{}에서 비동기 처리 중에 상태 갱신을 위해 setState()를 실행 했기 때문에 예외가 발생한 것 같다. 에러에서 Another solution is to check the \"mounted\" property of this object before calling setState() to ensure the object is still in the tree.라고 해결책을 주었길래, mounted를 체크하는 조건문을 추가해 주었더니 에러는 사라졌다. 당장 에러는 사라졌지만 사실 여전히 문제는 남아있고, 더 좋은 해결 방법이 있을 거다… 일단 보류하고 수정하면 포스팅을 업데이트 할 예정. #수정 보류중인 오류메세지를 입력한 후 ChatPage로 돌아오지 않고 ChatDetailPage에서 바로 마지막 메세지를 수정하는 후, ChatPage로 돌아오는 경우 수정 전의 메세지가 표시 된다. onTap의 비동기 처리로 인해 provider에서 데이터가 업데이트 되기 전에 ChatPage의 상태 갱신이 먼저 이루어지기 때문으로 보인다.완성된 화면다음 포스팅 내용기본기능은 얼추 다 넣은 것 같은데, provider/hive 사용 방식 개선 수정 보류 중인 오류들 개선 재밌어 보이는 플러그 인이 있으면 적용 진짜 메세지를 주고 받을 수 있도록혹시 새 프로젝트를 짠다면 구체적으로 뭘 만들기 정하기 UX/UI 공부를 해서 좀더 사용자 친화적인 프로그램 만들기를 해보고 싶다.UI에 대해서는 미적감각이 거의 없다 싶은 사람이고 UX/UI는 관련지식이 1도 없기 때문에, 이론 공부부터 해야한다. 공부하면 어떻게든 되겠지 허허후기음… 공부를 더 하도록… 이런식의 얼레벌레 코드를 어따 써" }, { "title": "Flutter 01 Simple Chat UI 응용 02 데이터 로컬 저장 및 읽기,쓰기_유저정보편 (+상태창 추가) ", "url": "/posts/Flutter-Simple-Chat-UI-EX02/", "categories": "Flutter, Simple Chat", "tags": "flutter, practice, programming", "date": "2022-09-03 14:08:00 +0900", "snippet": "이 포스트는 How to Build a Chat App UI With Flutter and Dart을 따라서 작성한 Flutter Simple Chat UI 을 응용하여 좀 더 그럴듯한 채팅앱을 구현하기 위한 과정을 다룬다.주요 내용/순서은 이하와 같다. 데이터 저장 환경 구축 데이터 저장 방법 선택 Hive를 사용한 로컬 데이터 베이스 구축 패키지 추가 오리지널 클래스 정의 TypeAdapter 클래스 자동 생성 ChatPage : 유저 추가, 삭제, 저장 코드 정리, UI 수정 채팅 유저 추가 및 저장 userDetailPage : 상태창 생성, 유저 데이터 갱신 상대의 프로필 사진 클릭 시, 상태창 표시 갤러리서 선택한 이미지를 배경 이미지로 설정 원문의 예제는 단순히 UI만 다루는 포스트이다 보니, 실제로 데이터를 전달하거나 저장하는 등 데이터를 처리하는 작업은 해주지 않는다. 그러므로 이번 포스트는 스스로 공부하며 추가한 코드이다.관련 포스트 Base, Chat 화면 구현 Chat Detail 화면 구현 응용 01 (Chat Detail 화면) 화면 간 데이터 전달, 메세지 입력 응용 02 데이터 로컬 저장 및 읽기,쓰기_유저정보편 (+상태창 추가) (현재포스트) 응용 03 데이터 로컬 저장 및 읽기,쓰기_메세지로그편환경 MacBook Air (M1, 2020) macOS Monterey (v12.4) Flutter 3.0.3 Dart 2.17.5 Visual Studio Code 1.69.0데이터 저장 환경 구축데이터 저장 방법 선택현재는 메세지을 입력해서 보내도, 채팅창을 한 번 나갔다 들어오면 리셋 되어, 초기 상태로 되돌아 온다.그렇기 때문에 내가 보낸 메세지 데이터를 로컬에 저장해서, 채팅창을 나갔다 들어와도 예전의 메세지 로그가 남아 있도록 해 볼 것이다. 고려한 방법 1. shared_preferences 플러그인 → 사용× shared_preferences 플러그인을 사용하면 Key-Value 데이터를 로컬 디스크에 저장할 수 있는데, 주의할 점이 오직 원시 타입만 사용 가능: int, double, bool, string, stringList 대용량 데이터 저장을 위해 설계되지 않음 라고 되어 있어서, 지금은 오리지널 클래스인 ChatUsers과 ChatMessage의 리스트를 저장해야하기에 이 플러그 인의 사용은 포기 고려한 방법 2. 로컬 파일 → 사용× 너무… 원시적이고 데이터 관리가 귀찮으므로 미래를 위해 기각! 고려한 방법 3. 로컬 데이터 베이스 → 사용○ 사용할 수 있는 로컬 데이터 베이스에는 여러 종류가 있는데, 여기에 대해서는 Top 5 Local Database Solutions for Flutter Development라는 아주 좋은 글이 있었다. 글에서 소개한 내용을 간단히 요약하면, SQLite sqflite 플러그인 : 가장 유명하고 많이 사용하는 플러그인 Floor 플러그인 : sqflite에 의존, sqflite이 지원하는 모든 것을 지원 + 다른 기능도 추가 Drift (Moor) 플러그인 : sqflite에 의존, querying API 를 포함해 매우 강력한 툴, 공식페이지 HiveNoSQL, Key-Value 데이터베이스, 속도가 빠름, 암호화 강력이상적인 use case 소규모 유연한 애플리케이션 : NoSQL 이기 때문에 ‘테이블’이 아닌 ‘박스’라는 개념이 사용되며, 어떠한 구조도 될 수 있는 ‘박스’는 동일한 유형의 개체에 대한 유연한 데이터 열이 필요한 경우 매우 유용 SembastNoSQL 데이터베이스, 데이터 관리 방식은 Hive와 비슷하지만, 아직 Hive에 미치지 못하는 기능, 성능을 가짐 ※　데이터베이스 서버 구축 or 클라우드 서비스 데이터 베이스 이용 → 추후 수정 가능성 있음 진짜로 채팅을 할 수 있도록 만드려면 송수신자가 서로 다른 네트워크에서 접근 할 수 있는 데이터 베이스가 필요할 테니, 앱이 그 수준까지 완성 되면 데이터 관리 방법을 꿔야 할 것이다… 그때 한 번 해보려고 한다. 앞으로 응용해서 만드려고 하는 채팅 앱의 경우, 다수의 유저를 염두에 두고 만드는 것도 아니며, 오로지 공부 목적이기에 데이터의 규모가 그리 커지지도 않을 것이다. 그리고 NoSQL DB를 한번도 안 써봐서 써보고 싶다ㅎ 위와 같은 이유로 이번엔 Hive를 이용하여 로컬 데이터 베이스를 구축해 보려한다.Hive를 사용한 로컬 데이터 베이스 구축이번 장은 【Flutter】Hiveの使い方를 참고해서 작성했다. 설명이 아주아주 친절하다.이 앱에서는ChatUsers과 ChatMessage의 저장소를 만들어 줄건데 (설명은ChatUsers로 작성), 순서는 이하와 같다. 필요한 패키지 추가 오리지널 클래스 ChatUsers 정의 ChatUsers의 TypeAdapter 클래스 자동 생성패키지 추가pubspec.yaml파일 dependencies와 dev_dependencies에 필요한 패키지의 최신 버전을 추가한다.dependencies: hive: ^2.2.3 hive_flutter: ^1.1.0dev_dependencies: hive_generator: ^1.1.3 build_runner: ^2.2.0 2022/9/3시점, hive의 최신 버전은 2.2.3, hive_flutter의 최신 버전은 1.1.0, hive_generator의 최신 버전은 1.1.3, build_runner의 최신 버전은 2.2.0 이다. 최신 버전은 각자 확인하고 변경해서 추가하자. 개발할 때에만 필요하고, 릴리즈 할 때에는 필요 없는 패키지는 dev_dependencies에 포함시킨다.여기서 (ChatUsers같은)오지지널 클래스의 TypeAdapter를 작성하기 위한 hive_generator와 build_runner는 개발할 때에만 필요하기 떄문에, dev_dependencies에 포함시킨 것.오리지널 클래스 정의저장하고 싶은 것은 메세지 로그이므로 생성해 두었던 chatUsersModel.dart를 이하와 같이 수정해 줄 것이다.import 'package:flutter/cupertino.dart';import 'package:hive/hive.dart'; //추가import 'package:uuid/uuid.dart'; //추가part 'chatUsersModel.g.dart'; //추가var uuid = Uuid();@HiveType(typeId: 1) //추가class ChatUsers { @HiveField(0) //추가 String id; //추가 @HiveField(1) //추가 String name; @HiveField(2) //추가 String messageText; @HiveField(3) //추가 String imageURL; @HiveField(4) //추가 String time; ChatUsers( {String? id, required this.name, required this.messageText, required this.imageURL, required this.time}) : id = id ?? uuid.v4();}추가해준 코드의 설명과 추가한 이유는 이하와 같다. String id; 데이터 베이스에 저장을 할 때, key가 될 속성이 필요하기 때문에, 추가해 주었다. id속성은 uuid플러그인을 이용해 생성자 실행 시에 자동으로 할당되도록 해주었다. SQL데이터베이스로 말하면 prime key같은 역할을 할 속성, name등 다른 속성으로 식별해 줄 수도 있지만, 이름은 겹칠 수도 있고…name 외의 속성도 딱히 prime key 역할은 못할 듯 ※ 그렇다고 진짜 hive에서 키로 설정할 속성을 (겹치면 절대 안되는)식별키로 인식하는건 아님 주의! 내가 아직 SQL식 사고에서 못벗어나서 만들어 준 것 뿐…! 진짜로 이렇게 사용하는 건지는 모르겠음 part ‘chatUsersModel.g.dart’;part는 part of와 한쌍으로 프로그램을 분할 할 때 사용하는 구문으로, 파일에 선언해주면 (이번의 경우) chatUsersModel.dart 와 chatUsersModel.g.dart 는 하나의 파일에 정의한 것과 같이 취급된다. chatUsersModel.g.dart파일은 TypeAdapter 클래스가 정의된 파일로, 아직 생성해 주지 않았으므로 빌드에러가 날 것이다. (바로 다음 단계에서 생성해 줄 것) ※ 추후 생성할 chatUsersModel.g.dart파일을 확인하면 part of 'chatUsersModel.dart' 가 선언되어 있는 것을 확인 할 수 있다. @HiveType(typeId:0~255의 숫자)Hive가 TypeAdapter 생성시, 각 클래스들을 식별 할 수 있도록 지정해 주는 것이며, 들어갈 수 있는 숫자 범위는 0~255이다. @HiveField(0~255의 숫자)Hive가 TypeAdapter 생성시, 각 필드들을 식별 할 수 있도록 지정해 주는 것이며, 들어갈 수 있는 숫자 범위는 0~255이다.TypeAdapter 클래스 자동 생성위에서 입력해 둔part 'chatUsersModel.g.dart'; 의 chatUsersModel.g.dart를 생성하는 작업을 해줄 것이다. 반드시 생성하고자 하는 클래스에 part '해당클래스명.g.dart'; 를 먼저 추가해준 후 진행해야한다! 그렇지 않으면 생성되지 않음VSCode 터미널(현재의 flutter 프로젝트 경로)에서 이하와 같은 커멘드를 입력flutter packages pub run build_runner build그러면[INFO] Generating build script...[INFO] Generating build script completed, took 181ms[INFO] Initializing inputs[INFO] Reading cached asset graph...[INFO] Reading cached asset graph completed, took 31ms[INFO] Checking for updates since last build...[INFO] Checking for updates since last build completed, took 428ms[INFO] Running build...[INFO] 1.0s elapsed, 0/1 actions completed.[INFO] 4.0s elapsed, 0/1 actions completed.[INFO] Running build completed, took 4.3s[INFO] Caching finalized dependency graph...[INFO] Caching finalized dependency graph completed, took 19ms[INFO] Succeeded after 4.3s with 2 outputs (2 actions)이런 로그가 출력되면서, chatUsersModel.dart와 같은 폴더에 chatUsersModel.g.dart이 생성된 것을 확인할 수 있다.앞서 설명했듯,chatMessageModel.dart도 똑같이 생성해 주었음!ChatPage : 유저 추가, 삭제, 저장코드 정리, UI 수정기존 코드에서 수정할 것도 있고 여러가지가 추가되기 때문에 chatPage.dart의 코드를 수정, 추가해 주었다. 스크롤하면 페이지 타이틀까지 스크롤되는 거 수정 Add new 버튼이 실제로 눌릴 수 있게 제스쳐 위젯 추가 User list 를 초기화 할 수 있는 버튼 추가 ListView의 User를 사이드 스와이프로 제거 (Dismissible) 할 수 있도록 추가이하 수정한 chatPage.dart 전문import 'package:flutter/material.dart';import 'package:flt_simple_chat_ex/models/chatUsersModel.dart';import 'package:flt_simple_chat_ex/widgets/conversationList.dart';class ChatPage extends StatefulWidget { @override _ChatPageState createState() =&gt; _ChatPageState();}class _ChatPageState extends State&lt;ChatPage&gt; { List&lt;ChatUsers&gt; chatUsers = [ ChatUsers( name: \"Jane Russel\", messageText: \"Awesome Setup\", imageURL: \"https://randomuser.me/api/portraits/men/1.jpg\", time: \"Now\"), ChatUsers( name: \"Glady's Murphy\", messageText: \"That's Great\", imageURL: \"https://randomuser.me/api/portraits/women/1.jpg\", time: \"Yesterday\"), ChatUsers( name: \"Jorge Henry\", messageText: \"Hey where are you?\", imageURL: \"https://randomuser.me/api/portraits/men/2.jpg\", time: \"31 Mar\"), ChatUsers( name: \"Philip Fox\", messageText: \"Busy! Call me in 20 mins\", imageURL: \"https://randomuser.me/api/portraits/women/2.jpg\", time: \"28 Mar\"), ChatUsers( name: \"Debra Hawkins\", messageText: \"Thankyou, It's awesome\", imageURL: \"https://randomuser.me/api/portraits/men/3.jpg\", time: \"23 Mar\"), ChatUsers( name: \"Jacob Pena\", messageText: \"will update you in evening\", imageURL: \"https://randomuser.me/api/portraits/women/3.jpg\", time: \"17 Mar\"), ChatUsers( name: \"Andrey Jones\", messageText: \"Can you please share the file?\", imageURL: \"https://randomuser.me/api/portraits/men/4.jpg\", time: \"24 Feb\"), ChatUsers( name: \"John Wick\", messageText: \"How are you?\", imageURL: \"https://randomuser.me/api/portraits/women/4.jpg\", time: \"18 Feb\"), ]; @override Widget build(BuildContext context) { return Scaffold( body: Column( //delete: SingleChildScrollView - 스크롤하면 페이지 타이틀까지 스크롤되는 거 수정 crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ SafeArea( child: Padding( padding: EdgeInsets.only(left: 16, right: 16, top: 10), child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ Text( \"Conversations\", style: TextStyle(fontSize: 23, fontWeight: FontWeight.bold), ), Row(children: &lt;Widget&gt;[ Container( // User list 를 초기화 할 수 있는 버튼 추가 padding: EdgeInsets.only(left: 8, right: 8, top: 2, bottom: 2), height: 30, decoration: BoxDecoration( borderRadius: BorderRadius.circular(30), color: Colors.green[50], ), child: GestureDetector( onTap: () async { print(\"Clear user list\"); }, child: Row( children: &lt;Widget&gt;[ Icon( Icons.cancel, color: Colors.green, size: 20, ), SizedBox( width: 2, ), Text( \"Clear\", style: TextStyle( fontSize: 14, fontWeight: FontWeight.bold), ), ], ), ), ), SizedBox( width: 4, ), Container( padding: EdgeInsets.only(left: 8, right: 8, top: 2, bottom: 2), height: 30, decoration: BoxDecoration( borderRadius: BorderRadius.circular(30), color: Colors.pink[50], ), child: GestureDetector( // Add new 버튼이 실제로 눌릴 수 있게 제스쳐 위젯 추가 onTap: () async { print(\"ADD NEW PRESSED\"); }, child: Row( children: &lt;Widget&gt;[ Icon( Icons.add, color: Colors.pink, size: 20, ), SizedBox( width: 2, ), Text( \"Add New\", style: TextStyle( fontSize: 14, fontWeight: FontWeight.bold), ), ], ), ), ) ]) ], ), ), ), Padding( padding: EdgeInsets.only(top: 16, left: 16, right: 16), child: TextField( decoration: InputDecoration( hintText: \"Search...\", hintStyle: TextStyle(color: Colors.grey.shade600), prefixIcon: Icon( Icons.search, color: Colors.grey.shade600, size: 20, ), filled: true, fillColor: Colors.grey.shade100, contentPadding: EdgeInsets.all(8), enabledBorder: OutlineInputBorder( borderRadius: BorderRadius.circular(20), borderSide: BorderSide(color: Colors.grey.shade100)), ), ), ), Flexible( //add: Flexible,SingleChildScrollView - 스크롤하면 페이지 타이틀까지 스크롤되는 거 수정 fit: FlexFit.tight, child: SingleChildScrollView( physics: BouncingScrollPhysics(), child: ListView.builder( itemCount: chatUsers.length, shrinkWrap: true, padding: EdgeInsets.only(top: 16), physics: NeverScrollableScrollPhysics(), itemBuilder: (context, index) { return Dismissible( //ListView의 User를 사이드 스와이프로 제거 (Dismissible) key: Key(chatUsers[index].toString()), onDismissed: (DismissDirection direction) { ScaffoldMessenger.of(context).showSnackBar(SnackBar( content: Text('${chatUsers[index].name} dismissed'))); setState(() { chatUsers.removeAt(index); }); }, background: Container( color: Colors.red, ), child: ConversationList( name: chatUsers[index].name, messageText: chatUsers[index].messageText, imageUrl: chatUsers[index].imageURL, time: chatUsers[index].time, isMessageRead: (index == 0 || index == 3) ? true : false, ), ); }, ), ), ), ], ), ); }}수정된 chatPage UI (유저 전부 삭제한 상태)채팅 유저 추가 및 저장이제 저저…흉!측한 List&lt;ChatUsers&gt; chatUsers를 날려버리고 코드를 예쁘게 만들어줄 차례다. 먼저 그 과정을 편하게 만들어줄 버튼 2개를 만들었다. Add New버튼을 누르면 유저이름을 입력 다이얼로그 창이 뜨고, 유저 이름을 입력할 경우에 그 유저가 추가 Clear버튼을 누르면 리스트에 있는 모든 유저가 삭제유저의 상태를 앱을 다시 시작해도 기억할 수 있도록 위에 구축해 놓은 hive를 사용해 저장할 것이다.그런데, 예쁘게 코드를 짜기 위해서는 hive와 더불어 위젯의 상태 관리를 하는 provider에 대해서도 알아야 했다.hive같은 데이터 베이스는 뭐가 중요하다? 무결성이 중요하다~ 언제, 어디서든지, 누가 봤을 때도 같은 상태의 데이터가 보여야한다. A위젯에서 보는 데이터는 오늘데이터고, B위젯에서 보는 데이터는 어제 데이터면 안된다. 이렇게 일관된 데이터에 모든 위젯이 접근하기 위해서는 상태관리가 필수 인데, 기존 Dart의 Stateless Widget과 Stateful Widget위젯으로 상태 관리를 하면, 부모 위젯/자식 위젯끼리 데이터를 일일히 전달하고 받고 어쩌고 난리난리를 피워야하기 때문에, 이 때 유용한 것이 provider이다.공유가 필요한 데이터의 provider를 만들어주고 거기에 해당 데이터와 제어할 수 있는 동작을 담아두면 provider가 정한 범위 내 속하는 어떠한 위젯이든 신선한 데이터에 아주 편하게 다이렉트로 접근을 할 수 있게 된다.provider에도 다양한 패키지가 있던데 나는 이번에 flutter_state_notifier를 사용했다. 필요한 패키지는 적재적소에 알아서 추가해 주자. flutter_state_notifier : main.dart provider : provider사용하는 곳에 필요 flutter_hive : provider에서 접근하므로 provider에 필요provider를 사용하기까지!① provider를 정의한다② provider를 생성한다(범위지정)③ provider를 사용한다말은 쉽다. 하나씩 해보자…① provider를 정의한다우리는 user에 대한 DB, message에 대한 DB를 만들어 줘야 한다.그러니까 providers라는 폴더를 만들어서 users.dart 와 messages.dart라는 파일을 만들어 주었다. 여기서는 users.dart을 기준으로 기록해두겠다. messages.dart도 구조는 비슷하다.users.dart에는 크게 상태를 관리하는 클래스 UserListPrState와 제어를 위한 클래스 UserListController가 있다.user 정보를 획득만 하고 싶으면 UserListPrState를 통해서, user 정보를 수정하거나 삭제하거나 하고 싶으면 UserListController를 통해서 하면 된다는 뜻.따라서 UserListPrState에서는 hive에 저장된 유저정보를 읽어들이고, 변경된 상태가 있으면 저장할 수 있는 기능을, UserListController에는 필요한 제어 함수를 작성하면 된다.import 'package:hive_flutter/hive_flutter.dart';import 'package:flt_simple_chat_ex/models/chatUsersModel.dart';Box&lt;ChatUsers&gt;? userList = Hive.box('users_log');class UserListPrState { List&lt;ChatUsers&gt; users; UserListPrState({ required this.users, }); factory UserListPrState.initial() { return UserListPrState(users: userList!.values.toList()); } UserListPrState copyWith({ List&lt;ChatUsers&gt;? users_cp, }) { return UserListPrState( users: users_cp ?? users, ); }}class UserListController extends StateNotifier&lt;UserListPrState&gt; { UserListController() : super(UserListPrState.initial()); // 유저 추가 void addUser(ChatUsers user) { final _users = [...state.users, user]; state = state.copyWith(users_cp: _users); // 상태 변경 userList!.put(user.id, user); // 데이터베이스 저장 } // 유저 삭제 (1명) void deleteUser(ChatUsers user) { final _users = state.users.where((m) =&gt; m.name != user.name).toList(); state = state.copyWith(users_cp: _users); // 상태 변경 userList!.delete(user.id); // 데이터베이스 저장 } // 유저 전부 삭제 void clearUser() async { state = state.copyWith(users_cp: []); await userList!.clear(); }}필요한 함수가 있으면 UserListController에 마구마구 추가해주면 된다. 여기서 맨 처음에 Box&lt;ChatUsers&gt;? userList = Hive.box('users_log'); 라는 걸 선언해 주었는데, ‘users_log’라는 이름의 user정보를 담는 박스가 곧 데이터베이스가 되는 것이다. 따라서 변수 userList는 곧 데이터베이스!처음에 box를 생성할 때는 반드시 초기화를 해주고 위에서 생성한 TypeAdapter 등록해주고 openbox를 해줘야하는데그걸 이렇게 main.dart에서 해주면 된다.void main() async { await Hive.initFlutter(); //초기화 Hive.registerAdapter(ChatUsersAdapter()); // TypeAdapter 등록 Hive.registerAdapter(ChatMessageAdapter()); // TypeAdapter 등록 await Hive.deleteFromDisk(); await Hive.openBox&lt;ChatUsers&gt;('users_log'); // openbox await Hive.openBox&lt;ChatMessage&gt;('messages_log'); // openbox runApp( MyApp(), );}openbox를 해준 다음에는 users.dart에서 처럼 Hive.box만으로 접근할 수 있게 된다.② provider를 생성한다(범위지정)provider의 범위는 그 provider를 생성한 그 부모위젯에 속하는 모든 자식위젯이 된다. 그래서 일반적으로는 앱 가장 상위에 있는 위젯에 생성하는 것 같다 (구글링해보니까 대부분 그렇게 쓰던데 아닐 수도 있음)나는 주제에 다른데 써보겠다고 혼자 머리싸메다가 많은 일을 겪고 결국 main.dart에 MaterialApp()에 생성해 주었다ㅎ 사서 고생을 한다.class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { // provider 생성 return MultiProvider( providers: [ StateNotifierProvider&lt;MessageListController, MessageListPrState&gt;( create: (_) =&gt; MessageListController(), ), StateNotifierProvider&lt;UserListController, UserListPrState&gt;( create: (_) =&gt; UserListController(), ), ], // provider 생성 builder: (context, child) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), debugShowCheckedModeBanner: false, home: HomePage()); }, ); }}이렇게 생성된 provider는 MaterialApp을 포함한 이하에 존재하는 모든 위젯에서 접근할 수 있게 된다. (MyApp에서는 접근 못함 주의!)MultiProvider는 여러 프로바이더를 관리할 수 있게 해주는 위젯인데, 앞으로 얼마나 늘어날지 몰라서 그냥 썼다.③ provider를 사용한다이제 필요한 위젯에서 접근하거나 제어해주면 된다.지금은 주로 chatPage.dart에서 users에, chatDetailPage.dart에서 messages접근하게 될텐데, 메세지 로그의 저장은 다음 포스팅에 기록하기로 하고, 이번엔 chatPage.dart에서 유저를 추가하고 삭제(+그 정보는 저장)하는 걸 해보자._ChatPageState 클래스에서 user의 상태를 취득하고 제어(추가, 삭제)를 할 수 있도록 먼저 프로바이더에 접근해준다. @override Widget build(BuildContext context) { final List&lt;ChatUsers&gt; _ustate = context.watch&lt;UserListPrState&gt;().users; // 상태 취득 final _uctlr = context.read&lt;UserListController&gt;(); // 제어 유저를 등록 : Add new 버튼을 눌렀을 때, _uctlr.addUser(_user);를 실행 Container( padding: EdgeInsets.only(left: 8, right: 8, top: 2, bottom: 2), height: 30, decoration: BoxDecoration( borderRadius: BorderRadius.circular(30), color: Colors.pink[50], ), child: GestureDetector( //add, GestureDetector onTap: () async { print(\"ADD NEW PRESSED\"); late final _user; DateTime now = DateTime.now(); String nowstring = new DateFormat.yMMMd('en_US').format(now); String? tempusername = await InputDialog(context); if (tempusername == \"\" || tempusername == null) { print(\"User Name is Empty!\"); tempusername = null; } else { print(\"Save to Database\"); String thisusername = tempusername; setState(() { _user = ChatUsers( name: thisusername, statusmsg: \" \", messageText: \" \", imageURL: \"https://randomuser.me/api/portraits/men/6.jpg\", time: nowstring, bgdimage: File(\"초기 셋팅할 String 타입 이미지경로 입력\")); _uctlr.addUser(_user); _textFieldController.clear(); }); } _uctlr.printUser(); }, child: Row( children: &lt;Widget&gt;[ Icon( Icons.add, color: Colors.pink, size: 20, ), SizedBox( width: 2, ), Text( \"Add New\", style: TextStyle( fontSize: 14, fontWeight: FontWeight.bold), ), ], ), ), )※ Dart의 late선언은 반드시 값이 필요한 (null이면 안되는, non-nullable) 변수지만, 선언과 동시에 초기화를 하지 않을 때 사용한다. 변수의 초기화를 뒤로 밀어줄 수 있는 것. 등록된 모든 유저를 삭제 : Clear 버튼을 눌렀을때 _uctlr.clearUser();를 실행 Container( padding: EdgeInsets.only(left: 8, right: 8, top: 2, bottom: 2), height: 30, decoration: BoxDecoration( borderRadius: BorderRadius.circular(30), color: Colors.green[50], ), child: GestureDetector( onTap: () async { _uctlr.clearUser(); //모든 유저를 삭제 }, child: Row( children: &lt;Widget&gt;[ Icon( Icons.cancel, color: Colors.green, size: 20, ), SizedBox( width: 2, ), Text( \"Clear\", style: TextStyle( fontSize: 14, fontWeight: FontWeight.bold), ), ], ), ), ), 지정한 유저를 삭제 : 리스트뷰의 특정 유저를 옆으로 스와이프를 했을 때, _ustate.removeAt(index); 실행 이때, _uctlr이 아닌 _ustate를 사용하는데 좀 위화감이 있긴한데, (유저의 id를 획득해 와서 유저를 특정해서 그 유저를 지우는 것보다) 리스트뷰의 index(몇 번째 유저인지)를 이용하여 컨트롤을 해주는게 더 코드가 간단해서 이렇게 해줬다. ListView.builder( itemCount: _ustate.length, shrinkWrap: true, padding: EdgeInsets.only(top: 16), physics: NeverScrollableScrollPhysics(), itemBuilder: (context, index) { return Dismissible( //사이드 스와이프로 삭제 key: UniqueKey(), onDismissed: (DismissDirection direction) { ScaffoldMessenger.of(context).showSnackBar(SnackBar( content: Text('${_ustate[index].name} dismissed'))); setState(() { _ustate.removeAt(index); }); }, background: Container( color: Colors.red, ), child: ConversationList( id: _ustate[index].id, name: _ustate[index].name, messageText: _ustate[index].messageText, imageUrl: _ustate[index].imageURL, time: _ustate[index].time, isMessageRead: (index == 0 || index == 3) ? true : false, user: _ustate[index], ), ); }, ),이런식으로 사용해주면 되는 것이다…………중간에 DB에 저장은 되는데 UI에 업데이트가 안되는 미치겠는 상황이 있었는데, 앱을 restart 했더니 해결되었다…(빡)결과, 요렇게 동작을 한다userDetailPage : 유저 데이터 갱신, 상태창 생성상대의 프로필 사진 클릭 시, 상태창 표시일단은 프로필을 구현한 conversationList.dart에 가서, 라운드한 프로필 모양에 따라 터치 이벤트를 발생시켜주면 되는데, 방법에는 여러가지가 있다.방법1. InkWell사용 : 프로필 사진의 원을 포함하는 사각형 모양으로 터치 반응 InkWell( onTap: () { print(\"CircleAvatar touch\"); }, child: CircleAvatar( backgroundImage: NetworkImage(widget.imageUrl), maxRadius: 30, ), ),방법2. GestureDetector사용 : 프로필 사진의 원 모양으로 터치 반응 Column(children: &lt;Widget&gt;[ SizedBox(height: 30.0), GestureDetector( onTap: () { print(\"CircleAvatar touch\"); }, child: CircleAvatar( backgroundImage: NetworkImage(widget.imageUrl), maxRadius: 30, ), ) ]),방법3. RawMaterialButton사용 : 프로필 사진의 원 모양으로 터치 반응 Stack( children: &lt;Widget&gt;[ CircleAvatar( backgroundImage: NetworkImage(widget.imageUrl), maxRadius: 30, ), RawMaterialButton( onPressed: () { print(\"CircleAvatar touch\"); }, child: Container( width: 60.0, // CircleAvatarのradiusの2倍 height: 60.0, ), shape: new CircleBorder(), elevation: 0.0, ), ], ),하여튼 CircleAvatar을 child로 두는 포함하는 버튼/제스처 위젯을 사용하든, Stack으로 CircleAvatar과 버튼 위젯을 겹쳐주든 하면 된다. 이외에도 방법은 여러가지가 있을 듯. 나는 방법1 사용.이제, 터치하면 새로운 페이지로 상태창을 띄워줄것이다 지금 위에 코드에서 print(\"CircleAvatar touch\");라고 되어있는 부분에 실제 코드를 넣어주면 된다.상태창을 그려줄 userDetailPage.dart를 screen폴더에 추가해 주었다.그리고 상태창에서 유저의 여러 속성에 접근하고 수정할 거라서 chatDetailPage에서처럼 유저의 속성을 id, imageUrl같이 각각 전달하지 않고 그냥 ChatUsers 클래스 전체를 전달했다. (그김에 chatDetailPage도 동일하게 수정)import 'package:flutter/material.dart';class UserDetailPage extends StatefulWidget { ChatUsers user; UserDetailPage({ Key? key, required this.user, }) : super(key: key); @override _UserDetailPageState createState() =&gt; _UserDetailPageState();}class _UserDetailPageState extends State&lt;UserDetailPage&gt; { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( elevation: 0, automaticallyImplyLeading: false, backgroundColor: Colors.white.withOpacity(0.5), flexibleSpace: SafeArea( child: Container( padding: EdgeInsets.only(right: 16), child: Container( color: Colors.transparent, child: Row( children: &lt;Widget&gt;[ IconButton( onPressed: () { Navigator.pop(context); }, icon: Icon( Icons.arrow_back_ios_new, color: Colors.black, ), ), ], ), ), ), ), ), ); }}만들어준 userDetailPage.dart 를 프로필 사진의 제스처에 연결해 주면 된다. InkWell( onTap: () { //추가 Navigator.of(context).push(MaterialPageRoute( builder: (context) { return UserDetailPage( cpuser: widget.user, ); }, )); //추가 END }, child: CircleAvatar( backgroundImage: NetworkImage(widget.user.imageURL), //수정, widget.imageurl -&gt; widget.user.imageURL maxRadius: 30, ), ),이제 프로필 사진을 클릭하면 이런 빈 화면이 뜰텐데, 이 상태창은 취향에 맞게 디자인 해주면 된다.나는 이런식으로 만들어 주었다. 상태메세지는 원래 유저 속성에 없었기 때문에 UI작업하면서 String statusmsg라는 변수타입/명으로 추가해 주었다. #수정 보류중인 오류이름이랑 상태메세지 정렬이 맘에 안들어서 나중에 수정상태창 UI의 버튼 목록 Appbar의 역화살표 아이콘 : ChatPage로 돌아가기 Appbar의 펜모양 아이콘 : 아직 아무 기능 없음 Appbar의 더하기 아이콘 : 배경 이미지를 변경 (다음 소챕터에 자세히 작성) 이름 옆의 펜 아이콘 : 이름 수정 상태메세지 옆의 펜 아이콘 : 상태메세지 수정 하단의 메세지 아이콘 : ChatDetailPage로 이동 하단의 전화 아이콘 : 아직 아무 기능 없음 하단의 정보 아이콘 : 아직 아무 기능 없음아이콘은 Flutter Icon Class 참고.UI중에 지금까지랑은 크게 다른건 Appbar의 백그라운드를 body뒤로 숨긴것 정도 이다. Scaffold위젯에서 extendBodyBehindAppBar 옵션은 true로 해주면 됨! 그 외에는 딱히 신경쓴건 없고 그냥 배치 구성만 잘 짜면 된다. 아주 제일 머리아프지… ... // 생략 return Scaffold( extendBodyBehindAppBar: true, //앱바 배경 숨기기 appBar: AppBar( ... // 생략그런데 위의 코드대로라면 유저의 이름을 수정한 후에 ChatPage로 돌아갔을 때 리스트뷰에 갱신내용이 반영이 되어있지 않은 것을 확인 할 수 있을 것이다. 그건conversationList에서 UserDetailPage로 Navigator.of(context).push할 때, 미래의 값을 기다려 줌(await)으로써 값이 수정되면 상태를 갱신(setState)하는 것으로 해결할 수 있다. InkWell( onTap: () async { //추가, async await Navigator.of(context).push(MaterialPageRoute( //추가, await builder: (context) { return UserDetailPage( cpuser: widget.user, ); }, )); setState(() {}); //추가 }, child: CircleAvatar( backgroundImage: NetworkImage(widget.user.imageURL), maxRadius: 30, ), ),갤러리서 선택한 이미지를 배경 이미지로 설정유저의 속성(/lib/models/chatUsersModel.dart)에 배경 이미지 속성(File bgdimage) 추가해주고,class ChatUsers { @HiveField(0) String id; // hive의 key로 지정하기 위해 추가 @HiveField(1) String name; @HiveField(2) String statusmsg; // 상태 메세지 @HiveField(3) String messageText; @HiveField(4) String imageURL; @HiveField(5) String time; @HiveField(6) File bgdimage; //배경 이미지 ChatUsers( {String? id, required this.name, required this.messageText, required this.statusmsg, required this.imageURL, required this.time, required this.bgdimage}) : id = id ?? uuid.v4(); ... // 생략}/lib/modelschatUsersModel.g.dart 파일 갱신을 위해서 터미널에서 명령어 실행flutter packages pub run build_runner build그런데 여기서 문제가 발생할 것이다… 왜냐하면, Hive는 File Type을 지원하지 않기 떄문이다. 코드를 수정한 후에 Add new로 유저를 추가해 주면, 이러한 「너 File의 Typeadapter를 추가하지 않았다. 추가해줘라.」라는 에러를 만나게 될 것이다.[VERBOSE-2:ui_dart_state.cc(198)] Unhandled Exception: HiveError: Cannot write, unknown type: _File. Did you forget to register an adapter?그리고 덩달아 나머지 속성들에 대한 저장도 제대로 되지 않는다. (아예 'user_log'박스가 제대로 동작하지 않는다) File의 Typeadapter를 알아서 작성하라는 거냐… 싶지만 인터넷에는 웬만한 찾아보면 있다.내가 참고한 글은 【Flutter】Hiveの対応しているオブジェクト以外も格納できるようにする 라는 글인데, 이 글에서 처럼 file_apdater.dart라는 파일을 만들어 주고, 만들어준 파일에 정의한 FileAdapter를 main.dart에 등록해 주면 된다. 그럼 에러가 없이 깔끔하게 실행되는 것을 확인 할 수 있다.이제 해결했으니 본론으로 돌아오겠다.배경 이미지 선택은 갤러리에서 사진을 가져오는 방식을 사용할 것이기 때문에, /ios/Runner/info.plist에 카메라, 앨범에 액세스 권한을 추가해주었다.(카메라는 아직 권한만 추가하고 미구현), 권한을 주지 않고 앨범에 접근하려고 하면 앱이 강제종료된다.\t&lt;string&gt;Access to take a photo by camera&lt;/string&gt;\t&lt;key&gt;NSAppleMusicUsageDescription&lt;/key&gt;\t&lt;string&gt;Access to pick a photo&lt;/string&gt;\t&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;\t&lt;string&gt;Access to pick a photo&lt;/string&gt;상태창 UI(/lib/screen/userDetailPage.dart)에 버튼을 만들어 주고 버튼을 누르면 갤러리에 접근할 수 있도록 해준다. IconButton( onPressed: () async { print(\"Add background Image\"); File _tempimg = await getImageFromGallery(); setState(() { _uctlr.editUserbgd(widget.cpuser.id, _tempimg); //해당 id유저의 bgdimage 속성값을 변경 }); }, alignment: Alignment.centerRight, icon: const Icon( Icons.add, color: Colors.black, ), )여기서 getImageFromGallery()에 await선언을 해주었는데, 이유는 getImageFromGallery()에서 반환된 값을 받아온 후에 파일 값을 갱신해야하기 때문이다.await선언을 해주지 않고 그냥 _tempimg에 반환값을 받아오려고 해도 어짜피 에러가 난다 getImageFromGallery()는 반환값이 Future&lt;File&gt;타입이기 때문이다.갤러리에 접근해서 이미지를 가져오는 함수(getImageFromGallery())는 이렇게 생겼다. Image Picker라는 플러그인을 사용해서 가져오니 pubspec.yaml에 dependencies추가해주고 사용할 위젯에 임포트 해주었다. File _bgdimage = File(\"초기 셋팅할 String 타입 이미지경로 입력\"); final ImagePicker picker = ImagePicker(); Future&lt;File&gt; getImageFromGallery() async { final pickedFile = await picker.pickImage(source: ImageSource.gallery); if (pickedFile != null) { setState(() { _bgdimage = File(pickedFile.path); }); return _bgdimage; } else { print('No image selected'); return _bgdimage; }이 때 getImageFromGallery 함수는 (배경 이미지)파일 값을 받는 비동기(Future&lt;File&gt;)처리를 해주었다. pickImage가 사용자가 갤러리에서 이미지를 선택하기까지 (혹은 선택을 취소할 때까지) 대기를 타다가 작업이 완료되면, 그제서야 값을 가져올수 있는 상태(await)이기 떄문이다. (이것 때문에 _tempimg에 값을 받아올 때도 await 필요)처음에는 _tempimg를 거치지 않고 _bgdimage 변수를 그대로 editUserbgd(widget.cpuser.id, _bgdimage) 이런식으로 넣어버렸었는데, 그러면 비동기화 때문에 _bgdimage 값이 변경되기 전에 재빌드가 먼저 되어버리고, 그 뒤에 _bgdimage 값이 변경되어서 배경 이미지가 바뀌지 않았다.UI에는 이렇게 BoxDecoration위젯을 사용해 주면 된다. ... // 생략 body: Container( //color: Colors.orange, //decoration과 함께 쓸 수 없는 속성 decoration: BoxDecoration( image: DecorationImage( image: FileImage(widget.cpuser.bgdimage), fit: BoxFit.fill, opacity: 0.3), ), ... // 생략완성된 상태창, 수정 데모 #수정 보류중인 오류상태메세지 바꿀 때 뜨는 다이얼로그를 이름 바꿀 때 쓰는 다이얼로그와 같이 써서, 타이틀이랑 힌트가 상황에 맞지 않게 뜨는 거 요수정다음 포스팅 내용이제 유저 정보는 데이터 베이스에 저장이 된다! 상태창에서 정상적으로 이름, 상태메세지, 배경이미지를 바꿀 수 있다.다음엔 유저 정보를 저장해 준 것처럼, 유저별로 메세지 로그를 저장해 주고 마지막에 대화했던 메세지 내용을 ChatPage에 표시해 주는 것을 해 볼 것이다.flutter의 상태 관리StatefulWidget(setState)Dart에서 기본적으로 제공하는 상태 관리 위젯과 함수Redux자세히 공부 안함 이런게 있다는 것만 앎, 나중에 공부하면 추가하기Stream + InheritedWidget/Scoped Model (BLoC)자세히 공부 안함 이런게 있다는 것만 앎, 나중에 공부하면 추가하하기Providerprovider package change_notifier state_notifier (flutter_state_notifier)change_notifier 을 좀 더 개선한 느낌, 이번에 이거 사용Provider 사용법에서 디지게 애먹었다 아놔…. 분명 제대로 쓴 거 같은데 계속 범위 외라고 떠서 해결방법 까지 한 200번의 성공의 어머니를 겪음ChatDetailPage()가MaterialPageRoute에서 빌드되고 있다는 것의 의미를 한!!!!!!참을 이해를 못해서 StateNotifierProvider를 이상한 곳에서 공급해 주고있는데, 왜 에러가 나는지 모르겠어서 진짜 미치고 돌아버리는 줄 알았다. 이론을 전혀 모르고 그냥 맨땅에 머리를 박으니까 이런데서 시간이 무지하게 들어간다. 지금 생각하면 이거가지고 이렇게 고생을 한 게 어이없어 보이지만, 덕분에 Provider의 범위에 대해서는 공부가 되었으니 오케입니다해결하면서 도움이 많이 된 사이트 Provider설명과 예제 Flutter(Provider+StateNotifier+freezed) Simple app state managementRiverpodriverpod package flutter_riverpodGetX, Provider, BLoC처럼 상태관리를 위한 패키지 (Provider의 확장판)참고 사이트 Riverpod설명과 예제참고하기 좋은 사이트 How to save data locally in Flutter위에서 언급한 로컬에 데이터 저장할 때 고려한 방법 3개(①shared_preferences ②로컬 파일 ③로컬 데이터베이스 : sqflite플러그인사용)에 대한 튜토리얼이 있다. flutter study flutter provider 사용법 기초후기글로 기록하면 한번에 톽딱!땋! 한 것처럼 보이는데 사실 쪼랩이라서 뭣만하면 모르는 게 나오기 때문에 시행착오를 굉장히 겪는다… 돌아버려 진짜,,, 이번거 완전 오래 걸렸고,,, 그래도 많이 배웠다.그리고 쓰다보니 생각보다 긴데, 나중에 좀 내용을 나누든가 해야겠다. 원래 메세지 로그 저장도 여기에 같이 쓰려다 너무 길어져서 나눈 건데, 그래도 기네" }, { "title": "Flutter 01 Simple Chat UI 응용 01 화면 간 데이터 전달, 메세지 입력 ", "url": "/posts/Flutter-Simple-Chat-UI-EX01/", "categories": "Flutter, Simple Chat", "tags": "flutter, practice, programming", "date": "2022-08-12 15:16:00 +0900", "snippet": "이 포스트는 How to Build a Chat App UI With Flutter and Dart을 따라서 작성한 Flutter Simple Chat UI 을 응용하여 좀 더 그럴듯한 채팅앱을 구현하기 위한 과정을 다룬다.주요 내용은 이하와 같다. 화면 간의 데이터 전달 메세지 입력 메세지 입력에 따른 Chat Detail 화면의 디테일한 UI 수정원문의 예제는 단순히 UI만 다루는 포스트이다 보니, 실제로 데이터를 전달하거나 저장하는 등 데이터를 처리하는 작업은 해주지 않는다. 그러므로 이번 포스트부터는 스스로 공부하며 추가한 코드이다.관련 포스트 Base, Chat 화면 구현 Chat Detail 화면 구현 응용 01 (Chat Detail 화면) 화면 간 데이터 전달, 메세지 입력 (현재포스트) 응용 02 데이터 로컬 저장 및 읽기, 쓰기 응용 03 데이터 로컬 저장 및 읽기,쓰기_메세지로그편환경 MacBook Air (M1, 2020) macOS Monterey (v12.4) Flutter 3.0.3 Dart 2.17.5 Visual Studio Code 1.69.0Chat 화면 -&gt; Chat Detail 화면에 데이터 전달Chat Detail 헤더 UI에 값 전달지금은 Chat 화면의 대화상대 리스트의 어떤 개체를 선택해도 Chat Detail 화면은 위와 같이 고정 된 헤더를 가진 화면이 실행될 뿐이지만, 헤더에 내가 선택한 대화 상대의 정보가 뜨게 만들어 주고 싶다.즉, 내가 Chat 화면의 리스트 중에서 어떤 개체를 선택하였는지, Chat Detail 화면에 전달할 필요가 있다.기본 개념 참고한 페이지 새로운 화면으로 데이터 보내기위의 페이지는 보면 onTap 내에서 Navigator.push 를 이용하여 todo리스트의 데이터를 전달해주는 예제이다. 전달해주는 데이터만 다를 뿐, 기본 개념은 같으므로 이 예제를 보고 따라하면 문제 없이 데이터를 전달해 해줄 수 있다.먼저, 작성한 simple chat ui 어플리케이션이 어떻게 생겨 먹었는지 그려보자.screen 인 ChatPage 안에 conversationList 위젯이 위치하고 있으며, 실질적인 리스트뷰의 출력이나 제스처 동작은 conversationList 에서 일어나고 있다는 것이 포인트다.이제 코드를 보면 위젯인 conversationList.dart 에서 onTap 내에 이미 Navigator.push 메서드가 ChatDetailPage() 를 리턴하도록 되어 있는 것을 알수 있다. onTap: () { Navigator.push(context, MaterialPageRoute(builder: (context) { return ChatDetailPage(); })); },우리가 할 일은 Navigator.push메서드가 단순히 ChatDetailPage() 를 리턴하는 것이 아니고, ChatDetailPage()페이지에 매개변수를 전달하도록 코드를 변경하는 것이다.chatDetailPage 페이지에 전달되어야 할 데이터는, String형태의 imageUrl과 name 이 2가지 이다. 각각 전달하는 것이 아니고, ChatUsers 객체를 전달해도 괜찮으나, 이번에는 그냥 각각 전달해 보겠다.conversationList에서 인자를 넘겨주기 전에, ChatDetailPage에서 인자를 받을 수 있도록 정의 부터 해줘야 한다.class ChatDetailPage extends StatefulWidget { //final ChatUsers chatuser; String cpname; String cpimageurl; ChatDetailPage({Key? key, required this.cpimageurl, required this.cpname}) : super(key: key); @override _ChatDetailPageState createState() =&gt; _ChatDetailPageState();}@override 위 쪽에, imageurl과 name가 들어 갈 변수를 정의해 준 후, 인자로 받을 수 있도록 생성자를 작성해 주었다. imageurl과 name 둘 다 필수적인 인자이니 required 지정.다시 conversationList로 돌아와서 인자를 전달해 주었다. onTap: () { Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; ChatDetailPage( cpimageurl: widget.imageUrl, cpname: widget.name, ), ) ; },여기까지 하면, conversationList의 imageurl과 name이 chatDetailPage로 넘어간 것이다! 이제 chatDetailPage의 해당 값(imageurl과 name)을 고정값이 아닌 선언했던 변수로 바꾸어 주면 끝! CircleAvatar 의 backgroundImage 키의 값을 \"https://randomuser.me/api/portraits/men/5.jpg\" 에서 widget.cpimageurl로 변경 Text 의 \"Kriss Benwat\" 를 widget.cpname 로 변경이하는 헤더(appBar) 전체 코드이다. appBar: AppBar( elevation: 0, automaticallyImplyLeading: false, backgroundColor: Colors.white, flexibleSpace: SafeArea( child: Container( padding: EdgeInsets.only(right: 16), child: Row( children: &lt;Widget&gt;[ IconButton( onPressed: () { Navigator.pop(context); }, icon: Icon( Icons.arrow_back, color: Colors.black, ), ), SizedBox( width: 2, ), CircleAvatar( backgroundImage: NetworkImage(widget.cpimageurl), //수정 maxRadius: 20, ), SizedBox( width: 12, ), Expanded( child: Column( crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( widget.cpname, //수정 style: TextStyle( fontSize: 16, fontWeight: FontWeight.w600), ), SizedBox( height: 6, ), Text( \"Online\", style: TextStyle( color: Colors.grey.shade600, fontSize: 13), ), ], ), ), Icon( Icons.settings, color: Colors.black54, ), ], ), ), ), ),결과물을 확인해 보면, 이제 chatDetailPage 페이지 헤더에 Chat 화면의 리스트에서 클릭한 사람의 이미지와 이름이 뜨는 것을 볼 수 있다.Chat Detail 화면 : 메세지 입력이제 채팅을 입력하는 화면에서 실제로 텍스트 박스(TextField)에 메세지를 입력하고 송신 버튼(FloatingActionButton)을 누르면 메세지 로그에 입력한 메세지가 띄워지도록해볼 것이다.메세지를 입력하는 부분인 TextField 클래스는 controller라는 키를 가지는데, 여기에 텍스틀를 제어하는 TextEditingController 인스턴스를 지정해 줄 수 있다.그러므로 TextEditingController 인스턴스를 선언해주고, controller 키에 만든 인스턴스를 지정하면 입력된 텍스트를 제어할 수 있게 된다.그렇게 입력된 텍스트를, 송신 버튼을 누르면 메세지 리스트에 저장하고 싶다. 그러면 FloatingActionButton 클래스의 onPressed 키에 입력된 값을 메세지 리스트에 추가하는 코드를 써주면 된다.일단 여기까지 입력된 텍스트가 제대로 변수에 저장이 되는지 확인해 보겠다.먼저 _ChatDetailPageState 클래스에 TextEditingController 인스턴스를 선언 final TextEditingController msgtextController = TextEditingController();확인을 위해 debugPrint로 콘솔에 변수 값을 출력해줘봄… Expanded( child: TextField( decoration: InputDecoration( hintText: \"Write message...\", hintStyle: TextStyle(color: Colors.black54), border: InputBorder.none), controller: msgtextController, //추가 ), ), SizedBox( width: 15, ), FloatingActionButton( onPressed: () { ChatMessage newMsg = ChatMessage( messageContent: msgtextController.text, messageType: \"sender\"); //추가, 변수에 입력값 저장 debugPrint('Input text : ${newMsg.messageContent}'); //추가, 확인을 위해 콘솔에 변수값 출력 messages.add(newMsg); //추가, 메세지 리스트에 새로운 메세지 추가 }, child: Icon( Icons.send, color: Colors.white, size: 18, ), backgroundColor: Colors.blue, elevation: 0, ),위의 gif 가장 하단에 보이는 검정색 바탕 화면이 콘솔화면인데, 시뮬레이터에 입력한 값이 제대로 출력되는 것을 볼 수 있다.이 값을 메세지 로그(바디)에 출력해 주기 위해서는 버튼을 눌렀을 때, 리스트 뷰를 다시 빌드해주는 setState() 함수를 호출하면 된다! FloatingActionButton( onPressed: () { ChatMessage newMsg = ChatMessage( messageContent: msgtextController.text, messageType: \"sender\"); //debugPrint('Input text : ${newMsg.messageContent}'); setState(() { messages.add(newMsg); }); //추가, 버튼을 누를 때 마다 리스트뷰 갱신 },결과물을 이하와 같다.메세지 입력에 따른 Chat Detail 화면의 디테일한 UI 수정제대로된 채팅 앱처럼 만들기 위해서는 그 외에도 여러가지 자잘한 작업이 필요한데, 메세지 송신 후, 메세지 필드 비우기화면을 보면 송신 후에도 입력했던 텍스트가 아직 텍스트 필드에 남아 있는 것을 알 수 있다.이때도 역시 텍스트 필드에 있는 값을 제어하는 것이므로, TextEditingController에 구현되어있는 clear() 함수 호출하면 쉽게 텍스트 필드를 비워 줄 수 있다. 텍스트 필드 멀티라인 입력텍스트 필드에 메세지를 입력해보면, 텍스트 필드의 길이를 초과하는 메세지를 입력해도 개행이 되지 않는 것을 알 수 있다. 이것을 텍스트 필드의 길이에 맞춰 자동으로 개행이 되도록(=멀티라인 입력이 가능하도록) 수정해 주었다. 바텀 높이 고정 해제, 맥스 높이 설정2에서 기왕 멀티라인이 입력되게 해주었는데, 바텀의 높이가 60으로 고정이 되어있어서 멀티라인이 입력되는게 잘 보이지 않는다. 그러므로, 고정되어있는 Container의 높이를 해제해 주고, ConstrainedBox위젯을 추가해 텍스트 필드로 인해 최대로 커질 수 있는 높이를 300으로 설정해 주었다. 수정 전 수정 후 송신메세지와 수산메세지 박스 정렬 수정이건 단순히 UI수정이므로, 취향에 따라 수정해 주면 된다.장문의 메세지일 경우, 원래는 송신메세지 박스와 수신메세지 박스가 모두 화면에 꽉 차는 상태인데, 나는 수신메세지의 경우 오른쪽에 좀 간격을 남기고, 송신메세지의 경우 왼쪽에 좀더 간격을 남기도록 메세지 박스에 마진을 설정해 주었다. 수정 전 수정 후 송신버튼 크기 고정이것도 단순 UI 수정이므로 취향에 따라… 원문대로라면 송신 버튼이 FloatingActionButton위젯으로 설정되어있어서, 텍스트 필드의 크기에 따라서 백그라운드의 크기가 멋대로 바뀔것이다. 매우 마음에 들지 않으므로 좌측의 버튼처럼 송신 버튼의 모양도 SizedBox로 감싸서 높이와 크기를 고정해 주었다.(3번의 스크린 샷에서 버튼이 고정되어있는 이유는 이미 수정 후에 스크린샷을 찍었기 때문) 송신버튼,첨부버튼 위치 고정이것도 단순 UI 수정이므로 취향에 따라… 마찬가지로 원문대로라면 좌측의 첨부 버튼, 송신 버튼 모두 텍스트 필드의 높이가 커짐에 따라서 위로 올라갈것이다.(높이 가운데 정렬이 됨) 나는 이걸 하단에 고정 시켜 주고 싶어서 정렬 Row위젯에 정렬을 추가해 주었다.(3번의 스크린 샷에서 버튼이 고정되어있는 이유는 이미 수정 후에 스크린샷을 찍었기 때문) 입력이 있을 때만 메세지 전송입력이 없을 때, 송신버튼을 눌러도 반응하지 않도록, FloatingActionButton위젯의 onPressed함수에 조건문을 추가해 주었다. 단, 지금은 스페이스 바나 엔터도 입력으로 취급한다. 나중에 걸러주는 코드를 추가할 예정… 메세지 로그 스크롤메세지 로그를 표시하는 Listview 위젯이 스크롤이 되지 않아서 메세지 내용의 길이가 스크린 화면을 벗어나면 더 이상 내용을 볼 수가 없다. 그래서 메세지 로그를 표시하는 리스트 뷰 위젯을 SingleChildScrollView 위젯으로 감싸주었다. 메세지 입력 시, 메세지 로그 가장 하단(최신)으로 이동 스크롤을 제어하기 위한 스크롤 컨트롤러를 선언해 준 후, 메세지 로그 부분에 스크롤 컨트롤러 추가 스크롤의 가장 마지막 부분으로 이동하는 _scrollToLatest라는 함수를 작성 FloatingActionButton위젯의 onPressed함수에서 작성한 _scrollToLatest를 호출 #수정 보류중인 오류스크롤이 없다가 생기는 경우, (처음 한 줄만) 스크롤이 제대로 이동을 안함 여기까지의 ChatDetailPage.dart 전체 코드 import 'package:flutter/foundation.dart';import 'package:flutter/material.dart';import 'package:flt_simple_chat_ex/models/chatMessageModel.dart';class ChatDetailPage extends StatefulWidget {String cpname;String cpimageurl;ChatDetailPage({Key? key, required this.cpimageurl, required this.cpname}) : super(key: key);@override_ChatDetailPageState createState() =&gt; _ChatDetailPageState();}class _ChatDetailPageState extends State&lt;ChatDetailPage&gt; {List&lt;ChatMessage&gt; messages = [ ChatMessage(messageContent: \"Hello, Will\", messageType: \"receiver\"), ChatMessage(messageContent: \"Hello, Jane\", messageType: \"sender\"),];final TextEditingController msgtextController = TextEditingController();//9. 추가, 스크롤 컨트롤러final ScrollController _scrollController = ScrollController();//9. 추가, 리스트 뷰의 가장 마지막(최신부분)으로 스크롤 이동void _scrollToLatest() { if (_scrollController.position.minScrollExtent == _scrollController.position.maxScrollExtent) { // 스크롤이 없을 때는, 스크롤 이동 하지 않음 } else { WidgetsBinding.instance.addPostFrameCallback((_) { _scrollController.jumpTo(_scrollController.position.maxScrollExtent); } ); }}@overrideWidget build(BuildContext context) { return Scaffold( appBar: AppBar( elevation: 0, automaticallyImplyLeading: false, backgroundColor: Colors.white, flexibleSpace: SafeArea( child: Container( padding: EdgeInsets.only(right: 16), child: Row( children: &lt;Widget&gt;[ IconButton( onPressed: () { Navigator.pop(context); }, icon: Icon( Icons.arrow_back, color: Colors.black, ), ), SizedBox( width: 2, ), CircleAvatar( backgroundImage: NetworkImage(widget.cpimageurl), maxRadius: 20, ), SizedBox( width: 12, ), Expanded( child: Column( crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( widget.cpname, style: TextStyle( fontSize: 16, fontWeight: FontWeight.w600), ), SizedBox( height: 6, ), Text( \"Online\", style: TextStyle( color: Colors.grey.shade600, fontSize: 13), ), ], ), ), Icon( Icons.settings, color: Colors.black54, ), ], ), ), ), ), body: Stack( children: &lt;Widget&gt;[ SingleChildScrollView( //8. 추가, 메세지 로그 스크롤 뷰 physics: BouncingScrollPhysics(), //8. 추가, 메세지 로그 스크롤 뷰 controller: _scrollController, //9. 추가, 스크롤 컨트롤러 child: ListView.builder( itemCount: messages.length, shrinkWrap: true, padding: EdgeInsets.only(top: 10, bottom: 70), physics: NeverScrollableScrollPhysics(), itemBuilder: (context, index) { return Container( padding: EdgeInsets.only(left: 16, right: 16, top: 10, bottom: 10), child: Align( alignment: (messages[index].messageType == \"receiver\" ? Alignment.topLeft : Alignment.topRight), child: Container( decoration: BoxDecoration( borderRadius: BorderRadius.circular(20), color: (messages[index].messageType == \"receiver\" ? Colors.grey.shade200 : Colors.blue[200]), ), padding: EdgeInsets.all(16), //4. 추가, 송신메세지(오른쪽 정렬, 왼쪽 간격 남기기)와 수산메세지(왼쪽 정렬, 오른쪽 간격 남기기) 박스 정렬 수정 margin: (messages[index].messageType == \"receiver\" ? EdgeInsets.only( left: 0, right: 64, top: 0, bottom: 0) : EdgeInsets.only( left: 64, right: 0, top: 0, bottom: 0)), //4. 추가 END child: Text( messages[index].messageContent, style: TextStyle(fontSize: 15), ), ), ), ); }, ), ), Align( alignment: Alignment.bottomLeft, child: ConstrainedBox( //3. 추가, 바텀의 맥스 높이 설정 constraints: BoxConstraints( maxHeight: 300, ), child: Container( padding: EdgeInsets.only( left: 10, bottom: 20, top: 0), //수정(임시), bottom10 top10 //height: 60, //3. 삭제, 바텀 고정 높이 해제 width: double.infinity, color: Colors.white, child: Row( crossAxisAlignment: CrossAxisAlignment .end, //6. 추가, 텍스트 필드가 길어져도 첨부, 송신버튼 하단으로 고정 children: &lt;Widget&gt;[ GestureDetector( onTap: () {}, child: Container( height: 30, width: 30, decoration: BoxDecoration( color: Colors.lightBlue, borderRadius: BorderRadius.circular(30), ), child: Icon( Icons.add, color: Colors.white, size: 20, ), ), ), SizedBox( width: 15, ), Expanded( child: TextField( decoration: InputDecoration( hintText: \"Write message...\", hintStyle: TextStyle(color: Colors.black54), border: InputBorder.none), controller: msgtextController, keyboardType: TextInputType.multiline, //2. 추가, 멀티라인 입력 가능하도록 maxLines: null, //2. 추가, 멀티라인 제한 없음 ), ), SizedBox( width: 15, ), //5. 추가, FloatingActionButton을 SizedBox로 감싸주고 height, width 설정 SizedBox( height: 30, width: 50, child: FloatingActionButton( onPressed: () { if (msgtextController.text.isNotEmpty) { //7. 추가, 입력이 있을 때만 전송 ChatMessage newMsg = ChatMessage( messageContent: msgtextController.text, messageType: \"sender\"); //debugPrint('Input text : ${newMsg.messageContent}'); setState(() { messages.add(newMsg); msgtextController.clear(); //1. 추가, 버튼을 누른 후 텍스트 필드 클리어 }); _scrollToLatest(); //9. 추가, 메세지 송신시, 가장 메세지 로그의 가장 최신 부분으로 이동 } }, child: Icon( Icons.send, color: Colors.white, size: 18, ), backgroundColor: Colors.blue, elevation: 0, ), ), ], ), ), ), ), ], ), ); }} 메세지 입력 시, 텍스트 필드 크기에 따라 메세지 로그 범위도 변경텍스트 필드의 높이가 높아지면, 메세지 로그 부분이 텍스트 필드에 맞춰서 위로 밀려났으면 좋겠는데, 지금은 그저 텍스트 필드가 커지는 만큼 메세지 로그가 가려져서 안보일 뿐이다.수정해준 작업은 이하와 같다. 메세지 로그와 바텀(입력부분)을 포함하는 body의 위젯의 종류를 Stack에서 Column으로 변경 그에 따라 변경된 자식 위젯들의 레이아웃을 수정하기 위해, 메세지 로그를 표시하는 SingleChildScrollView 위젯 밑에 Flexible 위젯을 하나더 깔아 줌 위젯의 크기를 취득, 갱신하는 _getWidgetInfo 와 _updateWidgetInfo 함수를 작성 텍스트 필드의 입력을 감지해서 바텀 부분의 위젯 높이가 변경될 경우 스크롤을 업데이트하도록 수정 #수정 보류중인 오류9번과 마찬가지로 맨 처음 개행이 될 때, (처음 한 문자만) 스크롤이 제대로 이동을 안함 스크롤이 메세지 로그 중간이 위치해 있을 경우, 입력도중에 바텀 크기가 바뀌어도 보던 화면 유지 #수정 보류중인 오류이것도 취향인데, 과거의 메세지를 보면서 텍스트 필더에 글을 입력할 때, 텍스트 필더의 높이가 높아져도 보던 메세지가 그대로 유지 되었으면 좋겠다. (지금은 그냥 텍스트 필더에 덮임)오프셋 계산하고 어쩌고 하면 될거같은데, 보류중,,, 여기까지의 ChatDetailPage.dart 전체 코드 import 'package:flutter/foundation.dart';import 'package:flutter/material.dart';import 'package:flt_simple_chat_ex/models/chatMessageModel.dart';class ChatDetailPage extends StatefulWidget {String cpname;String cpimageurl;ChatDetailPage({Key? key, required this.cpimageurl, required this.cpname}) : super(key: key);@override_ChatDetailPageState createState() =&gt; _ChatDetailPageState();}class _ChatDetailPageState extends State&lt;ChatDetailPage&gt; {List&lt;ChatMessage&gt; messages = [ ChatMessage(messageContent: \"Hello, Will\", messageType: \"receiver\"), ChatMessage(messageContent: \"Hello, Jane\", messageType: \"sender\"), ChatMessage(messageContent: \"aaaaaaaaaaaa\", messageType: \"receiver\"), ChatMessage(messageContent: \"bbbbbbbbbbbb\", messageType: \"sender\"), ChatMessage(messageContent: \"cccccccccccc\", messageType: \"receiver\"), ChatMessage(messageContent: \"dddddddddddd\", messageType: \"sender\"),];final TextEditingController msgtextController = TextEditingController();//9. 추가, 스크롤 컨트롤러final ScrollController _scrollController = ScrollController();//9. 추가, 리스트 뷰의 가장 마지막(최신부분)으로 스크롤 이동void _scrollToLatest() { print(_scrollController.position); int scrstatus = _scrollStatusChecker(); if (scrstatus == 0) { // 스크롤이 없을 때는, 스크롤 이동 하지 않음 print(\"No Scroll\"); } else if (scrstatus == 1) { WidgetsBinding.instance.addPostFrameCallback((_) { _scrollController.jumpTo(_scrollController.position.maxScrollExtent); }); } else if (scrstatus == 2) { WidgetsBinding.instance.addPostFrameCallback((_) { _scrollController.jumpTo(_scrollController.position.maxScrollExtent); }); } else { print(\"scroll error\"); }}void _scrollUpdater() { print(_scrollController.position); int scrstatus = _scrollStatusChecker(); if (scrstatus == 0) { // 스크롤이 없을 때는, 스크롤 이동 하지 않음 print(\"No Scroll\"); } else if (scrstatus == 1) { WidgetsBinding.instance.addPostFrameCallback((_) { _scrollController.jumpTo(_scrollController.position.maxScrollExtent); }); } else if (scrstatus == 2 &amp;&amp; _currentbottomheight == _minbottomheight) { WidgetsBinding.instance.addPostFrameCallback((_) { _scrollController.jumpTo(_scrollController.position.maxScrollExtent); }); } else if (scrstatus == 2 &amp;&amp; _currentbottomheight != _minbottomheight) { WidgetsBinding.instance.addPostFrameCallback((_) { //11. 입력도중에 바텀 크기가 바뀌어도 보던 화면 유지해주고 싶음 (미구현) _scrollController.jumpTo(_scrollController.offset); }); } else { print(\"scroll error\"); }}int _scrollStatusChecker() { int scrsta; if (_scrollController.position.minScrollExtent == _scrollController.position.maxScrollExtent) { // 스크롤이 없음 scrsta = 0; } else if (_scrollController.offset == _scrollController.position.maxScrollExtent) { // 스크롤이 최하단에 위치 scrsta = 1; } else { // 스크롤이 화면 중간에 위치 scrsta = 2; } return scrsta;}// 바텀 위젯 높이 변수 정의final double _maxbottomheight = 300; //바텀 높이 (맥시멈, 고정)double _minbottomheight = 0; //바텀 높이 (미니멈)double _currentbottomheight = 0; //바텀 높이 (현재)// 위젯(바텀,ConstrainedBox)용 키final GlobalKey _widgetKey = GlobalKey();@overridevoid initState() { super.initState(); // 바텀 높이 초기 셋팅 WidgetsBinding.instance.addPostFrameCallback(_getWidgetInfo);}//10. 추가, 위젯의 크기 정보 취득 (초기 세팅)void _getWidgetInfo(_) { final RenderBox renderBox = _widgetKey.currentContext?.findRenderObject() as RenderBox; final Size size = renderBox.size; double wgwidth = size.width; double wgheight = size.height; _minbottomheight = wgheight; _currentbottomheight = wgheight; print('Size: ${wgwidth}, ${wgheight}'); final Offset offset = renderBox.localToGlobal(Offset.zero); print('Offset: ${offset.dx}, ${offset.dy}'); print( 'Position: ${(offset.dx + size.width) / 2}, ${(offset.dy + size.height) / 2}');}// END, 위젯의 크기 정보 취득//10. 추가, 위젯 정보 갱신void _updateWidgetInfo() { final RenderBox renderBox = _widgetKey.currentContext?.findRenderObject() as RenderBox; final Size size = renderBox.size; double wgwidth = size.width; double wgheight = size.height; _currentbottomheight = wgheight; print('Size: ${wgwidth}, ${wgheight}'); final Offset offset = renderBox.localToGlobal(Offset.zero); print('Offset: ${offset.dx}, ${offset.dy}'); print( 'Position: ${(offset.dx + size.width) / 2}, ${(offset.dy + size.height) / 2}');}// END, 위젯 정보 갱신@overrideWidget build(BuildContext context) { double responsiveHeight = MediaQuery.of(context).size.height; print(\"responsiveHeight ${responsiveHeight}\"); return Scaffold( //resizeToAvoidBottomInset: true, appBar: AppBar( elevation: 0, automaticallyImplyLeading: false, backgroundColor: Colors.white.withOpacity(0.5), flexibleSpace: SafeArea( child: Container( padding: EdgeInsets.only(right: 16), child: Row( children: &lt;Widget&gt;[ IconButton( onPressed: () { Navigator.pop(context); }, icon: Icon( Icons.arrow_back, color: Colors.black, ), ), SizedBox( width: 2, ), CircleAvatar( backgroundImage: NetworkImage(widget.cpimageurl), maxRadius: 20, ), SizedBox( width: 12, ), Expanded( child: Column( crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( widget.cpname, style: TextStyle( fontSize: 16, fontWeight: FontWeight.w600), ), SizedBox( height: 6, ), Text( \"Online\", style: TextStyle( color: Colors.grey.shade600, fontSize: 13), ), ], ), ), Icon( Icons.settings, color: Colors.black54, ), ], ), ), ), ), body: Column( //10. 수정, Stack -&gt; Column children: &lt;Widget&gt;[ Flexible( //10. 수정, Container -&gt; Flexible fit: FlexFit.tight, //10. 추가, 여분 화면 없이 메세지 로그 화면 확장 // 추가, 컨테이너 위젯 &gt; 마진 추가하기 위해 child: SingleChildScrollView( //8. 추가, 메세지 로그 스크롤 뷰 physics: BouncingScrollPhysics(), //8. 추가, 메세지 로그 스크롤 뷰 controller: _scrollController, //9. 추가, 스크롤 컨트롤러 child: ListView.builder( itemCount: messages.length, shrinkWrap: true, padding: EdgeInsets.only( top: 10), //삭제, 컨테이너 위젯에 마진추가해 줬기 때문에 bottom: 70 삭제 physics: NeverScrollableScrollPhysics(), itemBuilder: (context, index) { return Container( padding: EdgeInsets.only( left: 16, right: 16, top: 10, bottom: 10), child: Align( alignment: (messages[index].messageType == \"receiver\" ? Alignment.topLeft : Alignment.topRight), child: Container( decoration: BoxDecoration( borderRadius: BorderRadius.circular(20), color: (messages[index].messageType == \"receiver\" ? Colors.grey.shade200 : Colors.blue[200]), ), padding: EdgeInsets.all(16), //4. 추가, 송신메세지(오른쪽 정렬, 왼쪽 간격 남기기)와 수산메세지(왼쪽 정렬, 오른쪽 간격 남기기) 박스 정렬 수정 margin: (messages[index].messageType == \"receiver\" ? EdgeInsets.only( left: 0, right: 64, top: 0, bottom: 0) : EdgeInsets.only( left: 64, right: 0, top: 0, bottom: 0)), //4. 추가 END child: Text( messages[index].messageContent, style: TextStyle(fontSize: 15), ), ), ), ); }, ), ), ), Align( alignment: Alignment.bottomLeft, child: ConstrainedBox( key: _widgetKey, //추가, 위젯 정보 얻기 위한 키 //3. 추가, 바텀의 맥스 높이 설정 constraints: BoxConstraints( maxHeight: _maxbottomheight, ), child: Container( //추가, 바텀의 맥스 높이 설정 padding: EdgeInsets.only( left: 10, bottom: 20, top: 0), //수정(임시), bottom10 top10 //height: 60, //3. 삭제, 바텀 고정 높이 해제 width: double.infinity, color: Colors.grey.withOpacity(0.3), child: Row( crossAxisAlignment: CrossAxisAlignment .end, //6. 추가, 텍스트 필드가 길어져도 첨부, 송신버튼 하단으로 고정 children: &lt;Widget&gt;[ GestureDetector( onTap: () {}, child: Container( height: 30, width: 30, decoration: BoxDecoration( color: Colors.lightBlue, borderRadius: BorderRadius.circular(30), ), child: Icon( Icons.add, color: Colors.white, size: 20, ), ), ), SizedBox( width: 15, ), Expanded( child: TextField( decoration: InputDecoration( hintText: \"Write message...\", hintStyle: TextStyle(color: Colors.black54), border: InputBorder.none), controller: msgtextController, onChanged: (text) { //텍스트 필드의 내용이 변경될 때 마다 감지 _updateWidgetInfo(); //10. 추가, 바텀 높이를 if (_currentbottomheight != _minbottomheight) { //10. 추가, 텍스트 필드 높이가 변하면 스크롤도 이동해줌 _scrollUpdater(); } }, keyboardType: TextInputType.multiline, //2. 추가, 멀티라인 입력 가능하도록 maxLines: null, //2. 추가, 멀티라인 제한 없음 ), ), SizedBox( width: 15, ), //5. 추가, FloatingActionButton을 SizedBox로 감싸주고 height, width 설정 SizedBox( height: 30, width: 50, child: FloatingActionButton( onPressed: () { if (msgtextController.text.isNotEmpty) { //7. 추가, 입력이 있을 때만 전송 ChatMessage newMsg = ChatMessage( messageContent: msgtextController.text, messageType: \"sender\"); debugPrint('Input text : ${newMsg.messageContent}'); setState(() { messages.add(newMsg); msgtextController .clear(); //1. 추가, 버튼을 누른 후 텍스트 필드 클리어 }); _scrollToLatest(); //9. 추가, 메세지 송신시, 가장 메세지 로그의 가장 최신 부분으로 이동 } }, child: Icon( Icons.send, color: Colors.white, size: 18, ), backgroundColor: Colors.blue, elevation: 0, ), ), ], ), ), ), ), ], ), );}} flutter 기초 : 참고하기 좋은 사이트 Flutter 화면 배치에 쓰는 기본 위젯 정리후기포스트를 작성하면서 느낀 점 다트에서는 대체로 위젯이라는 용어를 쓰나본데, 아직 클래스나 객체라는 단어가 익숙해서 혼동해서 쓰게 된다. 자잘한 수정은 한 개 수정할 때마다 코드를 첨부하기가 애매해서 번호를 매겨서 설명만 쭉 작성 후, 마지막에 전체 코드를 첨부, 코드안에 주석으로 몇 번에 해당하는 수정, 추가 사항인지 작성했다. 위의 전체 코드에서 10번, 11번을 포함시키지 않은 이유는, 지금까지 썼던 베이스 위젯의 종류를 아예 바꾸는 등 수정한 내용이 많았기 때문이다. 뭐든 그렇겠지만 처음부터 무슨 기능을 구현하고 싶은지 염두에 두고 알맞은 위젯을 쓰는게 가장 효율적일텐데 그게 참 어려운 부분이지…" }, { "title": "Flutter 01 Simple Chat UI 02 Chat Detail 화면", "url": "/posts/Flutter-Simple-Chat-UI-02/", "categories": "Flutter, Simple Chat", "tags": "flutter, practice, programming", "date": "2022-08-06 13:47:00 +0900", "snippet": "이 포스트는 How to Build a Chat App UI With Flutter and Dart을 따라서 작성한 Flutter Simple Chat UI 에 관한 내용이다.관련 포스트 Base, Chat 화면 구현 Chat Detail 화면 구현 (현재 포스트) 응용 01 (Chat Detail 화면) 화면 간 데이터 전달, 메세지 입력 응용 02 데이터 로컬 저장 및 읽기, 쓰기 응용 03 데이터 로컬 저장 및 읽기,쓰기_메세지로그편환경 MacBook Air (M1, 2020) macOS Monterey (v12.4) Flutter 3.0.3 Dart 2.17.5 Visual Studio Code 1.69.0Chatpage Detail : 화면 생성, 클릭 이벤트 적용/lib/screens/ 폴더에 chatDetailPage.dart 생성하여 이하의 베이스 코드를 작성해 준다.import 'package:flutter/material.dart';class ChatDetailPage extends StatefulWidget{ @override _ChatDetailPageState createState() =&gt; _ChatDetailPageState();}class _ChatDetailPageState extends State&lt;ChatDetailPage&gt; { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\"Chat Detail\"), ), body: Container() ); }}_ChatDetailPageState 클래스는 AppBar: 텍스트body: 빈 컨테이너가 포함된 Scaffold 위젯을 반환한다.conversationList에 표시된 개체 하나가 선택되었을 때, 이 화면을 활성화 해 주어야 하기 때문에,/lib/models/conversationList.dart 파일의 GestureDetector위젯, onTap 키의 값으로 해당 동작을 하는 코드를 추가해 줘야 한다.그전에 잊지 말자 임포트import 'package:flt_20220703_simple_chatapp/screen/chatDetailPage.dart'; onTap: () { Navigator.push(context, MaterialPageRoute(builder: (context) { return ChatDetailPage(); })); },그럼 이렇게 클릭 이벤트가 적용된다.Chatpage Detail UI 구현헤더 : UI 변경방금 만든 화면의 헤더에는 Chat Detail라는 텍스트만 써있지만, 보통은 대화를 나누는 사람의 정보가 들어간다. 그러니 대화 상대의 정보가 들어가는 UI를 만들어주자.헤더 정보를 수정하고 싶은거니까 어디를 수정해야한다? appBar키의 값을 수정해야한다~그냥 텍스트만 달랑 써주는 title: Text(\"Chat Detail\"),을 지워주고 이하의 코드를 작성한다. appBar: AppBar( elevation: 0, automaticallyImplyLeading: false, backgroundColor: Colors.white, flexibleSpace: SafeArea( child: Container( padding: EdgeInsets.only(right: 16), child: Row( children: &lt;Widget&gt;[ IconButton( onPressed: (){ Navigator.pop(context); }, icon: Icon(Icons.arrow_back,color: Colors.black,), ), SizedBox(width: 2,), CircleAvatar( backgroundImage: NetworkImage(\"https://randomuser.me/api/portraits/men/5.jpg\"), maxRadius: 20, ), SizedBox(width: 12,), Expanded( child: Column( crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text(\"Kriss Benwat\",style: TextStyle( fontSize: 16 ,fontWeight: FontWeight.w600),), SizedBox(height: 6,), Text(\"Online\",style: TextStyle(color: Colors.grey.shade600, fontSize: 13),), ], ), ), Icon(Icons.settings,color: Colors.black54,), ], ), ), ), ),그럼 헤더에 Chat Detail이라는 텍스트 대신, 이하와 같은 UI가 보일 것이다.바텀 : 텍스트 박스 추가이제 하단에 메세지를 입력할 수 있는 텍스트 박스와 송신 버튼, 이미지 등을 추가하기 위한 버튼을 배치해 주자.현재의 코드에서는 _ChatDetailPageState 클래스의 바디가 여전히 컨테이너만을 가지고 있을 것이다. ( body: Container()) )그러므로 body 의 값을 텍스트 박스, 버튼 개체를 표시해주는 코드로 변경한다.여기서는 이 개체들을 가로로 배치해 주고 싶기 떄문에 정렬(Align) 위젯을 사용, child 키의 값에 Row 위젯을 배치하여 그 안에 개채들을 넣어 주고 있다. body: Stack( children: &lt;Widget&gt;[ Align( alignment: Alignment.bottomLeft, child: Container( padding: EdgeInsets.only(left: 10,bottom: 10,top: 10), height: 60, width: double.infinity, color: Colors.white, child: Row( children: &lt;Widget&gt;[ GestureDetector( onTap: (){ }, child: Container( height: 30, width: 30, decoration: BoxDecoration( color: Colors.lightBlue, borderRadius: BorderRadius.circular(30), ), child: Icon(Icons.add, color: Colors.white, size: 20, ), ), ), SizedBox(width: 15,), Expanded( child: TextField( decoration: InputDecoration( hintText: \"Write message...\", hintStyle: TextStyle(color: Colors.black54), border: InputBorder.none ), ), ), SizedBox(width: 15,), FloatingActionButton( onPressed: (){}, child: Icon(Icons.send,color: Colors.white,size: 18,), backgroundColor: Colors.blue, elevation: 0, ), ], ), ), ), ], ),메세지 로그 : 메세지 추가이제 메세지 로그가 띄워지는 화면에 그럴 듯한 메세지가 띄워지는 것 같은 UI를 만들기 위해 일단 메세지를 입력해 줄 것이다./lib/models/ 폴더에 chatMessageModel.dart 생성하여 메세지 클래스를 작성해 준다.import 'package:flutter/cupertino.dart';class ChatMessage{ String messageContent; String messageType; ChatMessage({required this.messageContent, required this.messageType});} 여기서도 ChatMessage 클래스와 같은이유로, 원문과 같은 @required 어노테이션(Annotation)이 아닌 requried 로 대체해 주자다시 chatDetailPage.dart 파일로 돌아와서 표시될 메세지 리스트를 만들어 준다. 지금은 하드코딩(ㅋㅋ)을 해주지만 나중에는 수신된 메세지 리스트를 받아오면 될 것이다.먼저 작성한 모델을 임포트 해준후import 'package:flt_20220703_simple_chatapp/models/chatMessageModel.dart';이하의 리스트를 _ChatDetailPageState 클래스에 넣어주자. messageContent의 내용은 마음대로. List&lt;ChatMessage&gt; messages = [ ChatMessage(messageContent: \"Hello, Will\", messageType: \"receiver\"), ChatMessage(messageContent: \"How have you been?\", messageType: \"receiver\"), ChatMessage(messageContent: \"Hey Kriss, I am doing fine dude. wbu?\", messageType: \"sender\"), ChatMessage(messageContent: \"ehhhh, doing OK.\", messageType: \"receiver\"), ChatMessage(messageContent: \"Is there any thing wrong?\", messageType: \"sender\"), ];이제 데이터는 준비되었으니 이 데이터를 표시하는 UI를 추가해주자.이 메세지가 표시되는 곳은 body이지만, 바로 전 챕터에서 작성한 바텀의 윗부분에 배치해 주어야 하기 때문에 Stack 위젯 안쪽, 정렬(Align) 위젯 위쪽에, children 키를 추가하여 그 값으로 리스트 뷰를 빌드해 줘야한다. ListView.builder( itemCount: messages.length, shrinkWrap: true, padding: EdgeInsets.only(top: 10,bottom: 10), physics: NeverScrollableScrollPhysics(), itemBuilder: (context, index){ return Container( padding: EdgeInsets.only(left: 16,right: 16,top: 10,bottom: 10), child: Text(messages[index].messageContent), ); }, ),그럼 화면이 이렇게 데이터가 보여지게 된다.메세지 로그 : 송신자, 수신자 UI 작성메세지가 띄워지긴 헀지만, 채팅 페이지 같지는 않다. 이 메세지 내용들의 송신자, 수신자를 구분할 수 있도록 말풍선 UI안에 메세지가 띄워질 수 있도록 만들어 주자.방금 전 추가해 주었던 ListView의 itemBuilder키를 손봐줄 것이다.현재는 단순히 텍스트를 표시해주고 있는 것을 알 수 있는데 (child: Text(messages[index].messageContent),), 이곳을 Text위젯이 아닌 Align위젯으로 변경해 준 후, 배치할 요소들을 넣어줄 것이다. ListView.builder( itemCount: messages.length, shrinkWrap: true, padding: EdgeInsets.only(top: 10,bottom: 10), physics: NeverScrollableScrollPhysics(), itemBuilder: (context, index){ return Container( padding: EdgeInsets.only(left: 16,right: 16,top: 10,bottom: 10), child: Align( alignment: (messages[index].messageType == \"receiver\"?Alignment.topLeft:Alignment.topRight), child: Container( decoration: BoxDecoration( borderRadius: BorderRadius.circular(20), color: (messages[index].messageType == \"receiver\"?Colors.grey.shade200:Colors.blue[200]), ), padding: EdgeInsets.all(16), child: Text(messages[index].messageContent, style: TextStyle(fontSize: 15),), ), ), ); }, ),핫 로드를 해주면 이런 완성 화면이 나온다!후기작성자가 Flutter chat app 이라는 페이지를 소개하고 있는데 이런 채팅 앱의 템플릿을 판매하는 사이트니 참고할 사람은 참고하시길.개별 스크린 설계, 클릭 이벤트 같은 기본적인 UI 구현을 익히기 좋은 예제 같다.이 예제를 통해 만든 UI를 기반으로 화면 간의 값 전달이나 실제로 메세지를 주고 받을 수 있는 소켓 프로그래밍을 하면 결과가 눈에 보이면서 재밌을 것 같으니 해보도록 하겠다." }, { "title": "Github Blog 02 Chirpy Theme Setting ", "url": "/posts/Github-Blog-Setting-01/", "categories": "Github, Blog", "tags": "github, blog, writeup", "date": "2022-07-23 12:24:06 +0900", "snippet": "이 포스트는 jekyll Chirpy Theme의 설정을 이것저것 기록해 놓은 내용이다.Chirpy 테마를 사용하고 있어서 Chirpy 테마 세팅이라고는 했는데, 사실 테마에 한정되어 있기 보다는 jekyll과 Markdown 사용팁에 가깝다.기본적으로 제작자가 제공해준 정보를 보고 그냥 내가 설정한 내용만 뽑아 정리해 놓은 내용이니, 자세한 건 이하의 제작자 공식 튜토리얼 포스트를 참고하도록 하자. Customize the Favicon Writing a New Post타이틀에 (영문)형식으로 링크를 걸어놓은 항목은 원문 포스트의 관련 부분을 맵핑해 놓은 것이니 이해가 안되면 그쪽으로 들어가 원문을 보면 된다.본인 정보로 수정_config.yml (Configuration) 로컬 서버로 수정 확인을 하는 경우, _config.yml 수정 후에는 반드시 로컬 서버를 재기동 해줘야 수정이 반영된다.공식페이지를 보면 _config.yml의 url avatar timezone lang이 4항목의 수정을 하라고 하는데, 이건 최소한이고 실제로는 이것저것 많이 수정해 줘야한다.그냥 본인의 정보를 넣는 곳이다 싶은 키는 전부 수정해주면 된다. 수정하는거다 싶은 목록을 테이블로 작성했보았다. 되도록 _config.yml 에 작성되어있는 순서로 적었다. key value format value example specific lang 언어 코드 알파벳 두글자 en _data/locales폴더에 있는 파일 이름의 앞 2글자라고 생각하면 쉽다. en이 기본 값인데, 한국어를 쓰고싶으면 kr로 변경. timezone TZ database name 형식 Asia/Seoul 한국에서 이용중인 경우는 Asia/Seoul, 그 외 지역은 timezone database를 참고. title * Kae’s Dev 본인의 블로그 타이틀 tagline * honyarara 블로그 타이틀 밑에 출력되는 간단한 소개글 description * Developer, Study, Github, Programming 검색 엔진에 걸릴 키워드들을 ,로 구분해 입력 url github blog url https://kaesknzxvf.github.io 이 블로그의 url, github blog 니까 당연히 https://repository명.github.io 형식 github.username * kaesknzxvf github 계정 입력 twitte.username * kzaxevsf52 twitter 계정 입력 social.name * kae 사용할 닉네임 입력 social.email email 주소 kaesknzxvf@gmail.com 사용할 이메일 주소 입력 social.links - SNS urls - https://twitter.com/kzaxevsf52 - https://github.com/kaesknzxvf 본인의 SNS 링크들 입력, 문자열 선두에 - 를 포함해 개행하여 구분 google_site_verification sitemap content code 생략 google sitemap을 작성할 때 제공해주는 컨텐츠 코드를 복사해 입력, sitemap 등록 전에는 생략 google_analytics.id G-xxxxxxxxxx 생략 google analytics 등록 코드를 입력, sitemap과 마찬가지로 등록 전에는 생략 theme_mode light 또는 dark dark 블로그의 테마 색상 선택 img_cdn CND url https://cdn.com CND(Content Delivery Network) 주소가 있으면 넣어주면 된다. 난 없어서 생략 avatar 이미지 경로 /assets/img/main_img.png 프로필 이미지의 경로를 입력 toc bool true Table of Contents, 게시물 오른쪽에 목차를 표시할지 여부 paginate 숫자 10 한 페이지에 몇 개의 포스트를 출력할지 설정 ABOUT 페이지친절하게 팁이 써져있다. _tabs/about.md 파일을 마크다운으로 작성해 주면 된다.자기소개를 적으면 되는데, 뭐.. 적을 만한게 없어서 방치중UI 커스텀보이는 거 관련해서 수정한 설정Footer 출력 정보 수정Footer는 블로그 맨 하단의 저자, 소유권/저작권 등을 나타내는 정보인데 chirpy 테마에서는 이하와 같이 표시되며, _include/footer.html 에서 수정할 수 있다.&lt;!-- The Footer --&gt;&lt;footer class=\"row pl-3 pr-3\"&gt; &lt;div class=\"col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0\"&gt; &lt;div class=\"footer-left\"&gt; &lt;p class=\"mb-0\"&gt; © {{ 'now' | date: \"%Y\" }} &lt;a href=\"{{ site.social.links[0] }}\"&gt;{{ site.social.name }}&lt;/a&gt;. {% if site.data.locales[lang].copyright.brief %} &lt;span data-toggle=\"tooltip\" data-placement=\"top\" title=\"{{ site.data.locales[lang].copyright.verbose }}\"&gt;{{ site.data.locales[lang].copyright.brief }}&lt;/span&gt; {% endif %} &lt;/p&gt; &lt;/div&gt; &lt;div class=\"footer-right\"&gt; &lt;p class=\"mb-0\"&gt; {% capture _platform %} &lt;a href=\"https://jekyllrb.com\" target=\"_blank\" rel=\"noopener\"&gt;Jekyll&lt;/a&gt; {% endcapture %} {% capture _theme %} &lt;a href=\"https://github.com/cotes2020/jekyll-theme-chirpy\" target=\"_blank\" rel=\"noopener\"&gt;Chirpy&lt;/a&gt; {% endcapture %} {{ site.data.locales[lang].meta | default: 'Powered by :PLATFORM with :THEME theme.' | replace: ':PLATFORM', _platform | replace: ':THEME', _theme }} &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/footer&gt;코드를 보면 왼쪽(class=\"footer-left\")에는 블로그 소유자(나), 오른쪽에는 테마 제작자의 정보를 출력하도록 되어있는 걸 알 수 있다. 딱히 수정하지 않아도 되지만, 나는 오른쪽(class=\"footer-right\")은 그냥 냅두고 왼쪽의 정보를 지워줄 것이다. 심플하게 지우고 싶은 정보를 주석처리 해주면 끝. class=\"footer-right\" 의 div 블럭을 전부 주석처리 해주었다.적용 결과 왼쪽의 ‘Powered by ~ ‘가 사라진 걸 볼 수 있다.사이드 바 꾸미기사이드 바 관련 UI는 _sass/addon/commons.scss의 #sidebar {} 항목에서 수정해 줄 수 있다.나는 별건 안하고 사이드 바에 예쁜 사진을 넣어줬는데, background키의 값을 이미지의 경로로 바꿔 주면 된다.원래는 이렇게 --sidebar-bg라는 지정한 색상을 나타내는 변수가 지정되어 있을 텐데,background: var(--sidebar-bg);형식을 url로 바꿔 주고 안에 이미지의 경로를 입력해 주면 된다.background: url(&lt;img_path&gt;); &lt;xxxxxxx&gt; 의 값은 본인 환경에 맞게 수정이미지를 넣지 않고 색만 바꿔주고 싶다면 --sidebar-bg의 값을 수정해 주면 되는데, 이 변수는 _sass/colors/light-typography.scss와 _sass/colors/dark-typography.scss 에서 변경할 수 있다.이름에서 알 수 있듯이 light-typography.scss는 밝은 배경일 때의 색 설정, dark-typography.scss는 어두운 배경일 때의 색 설정이다. 각각 바꿔주면 된다.각 파일을 보면 --sidebar-bg 이외에도 사이드 바 관련해서 이하의 변수가 설정되어 있는 것을 볼 수 있는데, --sidebar-muted-color: #a2a19f; --sidebar-active-color: #424242; --nav-cursor-color: #757575; --sidebar-btn-bg: white;이 변수들은 사이드 바에 있는 글씨의 색을 설정하는 변수다.사이드 바의 배경색상이나 설정한 이미지의 채도에 따라 이 값을 바꿔줘야 글씨가 잘 보일테니, 적당히 설정을 변경해 주자.사이드 바 하단: 컨텍트 아이콘 표시 여부, 링크 수정_data/contact.yml 에서 표시할 아이콘을 수정 할 수 있다.기본적으로 이하의 7개의 정보가 이미 입력되어있는데 github twitter email rss mastodon linkedin stack-overflow초기 상태에서는 github, twitter, email, rss 가 활성화되어 있을 거다.자기가 사용하고 싶은 링크만 남기고 커멘드 아웃 해주면 된다. 이때, 원래 커멘드 아웃 되어있던 mastodon, linkedin, stack-overflow 같은 경우는 직접 url을 추가해 줘야한다.나는 github, twitter, rss, linkedin 로 남겨 놓음.Favicon 수정 (Customize the Favicon)홈페이지의 심볼아이콘인, favicon을 변경해보자. 초기상태의 chirpy 테마 favicon은 수박을 먹는 개미친구로 되어있다. 귀여움.이걸 내가 원하는 아이콘으로 바꿔줄 건데, 나는 내가 찍은 큐브 사진을 사용했다.자기가 아이콘으로 하고 싶은 이미지를 선택했으면, Real Favicon Generator 사이트에 들어가서 favicon 패키지를 생성해 주면 된다.Select your Favicon image를 누르면 이지미를 제출할 수 있는데, 최소 70x70 픽셀의 이미지를 제출하라고 되어있으니 그것만 주의해서 이미지를 제출해주자. 그러면 로딩바가 나오는데 좀 기다리면 자동으로 favicon 패키지를 생성해준다.그럼 이런 페이지가 나오면서 데스트답에서 내가 설정한 아이콘이 어떻게 보여질지 미리보기를 보여주는데, 여기서 아이콘의 사이즈, 아이콘 테두리의 사각 라운딩 정도, 배경색이 투명일 경우 배경색을 커스텀 할 수 있다.데스크 탑에서 뿐만 아니라 iOS Web Clip, Android Chrome, Windows Metro, macOS Safari 에서의 미리보기와 각각 커스텀도 가능하니 필요하면 설정을 하면 된다.그런 설정들을 지나서 맨 하단에 도착하면 Generate your Favicons and HTML code 라는 버튼이 있는데, 이걸 클릭하면 설정한 favicon 들을 압축해서 다운받을 수 있다. 별 설정하지 않고 그냥 다운 받았긴했지만, 참 유능한 사이트…다운 받은 파일favicon_package_v0을 열어보면 이하의 파일 9개가 들어있을 것이다..├── favicon_package_v0│   ├── android-chrome-192x192.png│   ├── android-chrome-512x512.png│   ├── apple-touch-icon.png│   ├── browserconfig.xml│   ├── favicon-16x16.png│   ├── favicon-32x32.png│   ├── favicon.ico│   ├── mstile-150x150.png│   └── site.webmanifest이 중에서 이 두 파일은 삭제해주자. 원래 테마에 들어있는 파일을 사용할 것이다. browserconfig.xml site.webmanifest그 후 나머지 파일을 assets/img/favicon 로 옮긴다. 원래 있던 파일들을 전부 덮어쓰기하면 된다.그 후 페이지를 새로고침하여 favicon 이 적용된 걸 확인하면 끝~ 캐시때문에 바로 안바뀔수 있으니 캐시 삭제하고 새로고침하면 바로 확인 할 수 있다.포스트 (Post) 관련포스팅 페이지 관련한 설정저자 정보 재정의 (Authors info)포스트를 발행하면 타이틀과 발행시간 밑에 ‘By저자’가 출력되는데, 이 저자 정보를 재정의하는 방법이다._data/authors.yml 파일의 내용을&lt;author_id&gt;: name: &lt;full name&gt; twitter: &lt;twitter_of_author&gt; url: &lt;homepage_of_author&gt; &lt;xxxxxxx&gt; 의 내용은 본인의 정보를 입력로 세팅 해준 후, 해당 포스트의 yaml block에 author라는 키값을 추가, 위의 설정한 author_id를 값으로 넣어주면 된다. 파일을 열어보면 초기 상태로 테마 제작자의 정보가 입력되어 있을텐데, 수정을 해주면 된다.---author: &lt;author_id&gt;--- &lt;xxxxxxx&gt; 의 내용은 본인의 정보를 입력사실 이런 세팅을 해주지 않아도 ‘By저자’는 _config.yml 파일에 세팅한social: name: &lt;your_name&gt; &lt;xxxxxxx&gt; 의 내용은 본인의 정보를 입력의 정보를 가져와서 자동으로 입력이 되지만, _data/authors.yml 에서 세팅한 내용으로 재정의를 해주면 twitter 계정 정보가 추가 되어서 검색이 되기 쉽고, 입력해준 url이 하이퍼 링크로 들어가서 저자를 클릭했을 때 내가 원하는 페이지로 연결해 줄 수 있다.나는 url에 깃헙 주소를 입력해 두었다.이미지 파일 경로 (Image path)포스팅 할 때, 이미지를 넣다보면![img-description](/assets/img/post01/image.png)이런식으로 작성하게 되는데, 이미지의 크기나 정렬, 스타일은 그때그때 따라 달라질 수 있으니 하나하나 설정하는 게 별로 불편하다고 생각이 되지 않지만, 파일 경로만큼은 입력이 귀찮다.어짜피 대부분은 /assets/img/... 의 하위폴더에 위치할 것이기 때문에…그런 이유로 해당 포스트의 yaml block 에 img_path 키를 추가하여---img_path: /assets/img/post01/--- 이미지 경로는 임의 값, 본인 환경에 맞게 수정이미지 파일의 절대 경로를 미리 입력해 두면, 글을 작성할 때에는![img-description](image.png) 이미지 파일이름은 임의 값, 본인 환경에 맞게 수정이런 식으로 파일 이름만으로 이미지 경로를 설정할 수 있기 때문에 편하다. 이미지 파일을 저장하는 폴더 이름이 바뀌어도 img_path 값 하나만 수정해주면 되기 때문에 관리도 편하고.내 경우는 포스팅 하나에 사용되는 이미지를 전부 /assets/img/포스트의 이름과 같은 이름의 폴더/ 에 넣어놓는 스타일이라 매우 유용.포스트 고정 (Pinned post)특정 포스트를 고정하고 싶을 때, 해당 포스트의 yaml block 에 pin 키를 추가하여 true로 설정하면 끝---pin: true---이렇게 표시 되면서 Home 화면의 맨 위로 포스트가 고정 된다.후기jekyll 개발자 대단스" }, { "title": "Flutter 01 Simple Chat UI 01 Chat화면", "url": "/posts/Flutter-Simple-Chat-UI-01/", "categories": "Flutter, Simple Chat", "tags": "flutter, practice, programming", "date": "2022-07-10 13:10:06 +0900", "snippet": "이 포스트는 How to Build a Chat App UI With Flutter and Dart을 따라서 작성한 Flutter Simple Chat UI 에 관한 내용이다.관련 포스트 Base, Chat 화면 구현 (현재 포스트) Chat Detail 화면 구현 응용 01 (Chat Detail 화면) 화면 간 데이터 전달, 메세지 입력 응용 02 데이터 저장 및 읽기, 쓰기 응용 03 데이터 로컬 저장 및 읽기,쓰기_메세지로그편환경 MacBook Air (M1, 2020) macOS Monterey (v12.4) Flutter 3.0.3 Dart 2.17.5 Visual Studio Code 1.69.0메인 화면 생성/lib/main.dart 파일 내용을import 'package:flutter/material.dart';void main() { runApp(MyApp());}class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), debugShowCheckedModeBanner: false, home: Container(), ); }}로 변경lib폴더에 screen폴더를 추가 homePage.dart 파일을 생성/lib/screen/homePage.dart 파일에import 'package:flutter/material.dart';class HomePage extends StatelessWidget{ @override Widget build(BuildContext context) { return Scaffold( body: Container( child: Center(child: Text(\"Chat\")), ), ); }}을 입력/lib/main.dart 에 좀전에 만든 파일을 임포트 해준 후,import 'package:flt_20220703_simple_chatapp/screen/homePage.dart';코드 중 home: Container(), 을 home: HomePage(), 로 변경여기까의 /lib/main.dart 의 전체 코드import 'package:flutter/material.dart';import 'package:flt_20220703_simple_chatapp/screen/homePage.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), debugShowCheckedModeBanner: false, home: HomePage(), ); }}메인 화면: 하단바 추가/lib/screen/homePage.dart 파일의 Scaffold 클래스의 내용을 변경해주자 return Scaffold( body: ChatPage(), bottomNavigationBar: BottomNavigationBar( selectedItemColor: Colors.red, unselectedItemColor: Colors.grey.shade600, selectedLabelStyle: TextStyle(fontWeight: FontWeight.w600), unselectedLabelStyle: TextStyle(fontWeight: FontWeight.w600), type: BottomNavigationBarType.fixed, items: [ BottomNavigationBarItem( icon: Icon(Icons.message), label: 'Chats', ), BottomNavigationBarItem( icon: Icon(Icons.group_work), label: 'Channels', ), BottomNavigationBarItem( icon: Icon(Icons.account_box), label: 'Profile', ), ], ), ); 원문에는 BottomNavigationBarItem 에 title 키로 텍스트를 입력하고 있는데, 버전 1.22 이후에는 title 대신 label 키를 쓰도록 바뀌었다Chatpage : 대화 목록 화면 구현lib/screen폴더에 chatPage.dart 파일을 생성/lib/screen/chatPage.dart 파일에import 'package:flutter/material.dart';class ChatPage extends StatefulWidget { @override _ChatPageState createState() =&gt; _ChatPageState();}class _ChatPageState extends State&lt;ChatPage&gt; { @override Widget build(BuildContext context) { return Scaffold( body: SingleChildScrollView( child: Center(child: Text(\"Chat\")), ), ); }}을 입력/lib/screen/homePage.dart 파일에import 'package:flt_20220703_simple_chatapp/screen/chatPage.dart';임포트 해주고 return Scaffold( body: Container( child: Center(child: Text(\"Chat\")), ),를 return Scaffold( body: ChatPage(),로 변경변한건 별로 없어 보이지만, chat이라고 텍스트만 쓰여져 있던 화면이 아닌, 새로운 레이어로 덮혀진 상태라는 걸 알 수 있다.헤더를 만들어주자이제부터 본격적으로 chat page ui를 만들어 주는 작업/lib/screen/chatPage.dart 파일에 _ChatPageState 클래스 build위젯 내용을 수정해서 대화 목록을 표시할 것임 return Scaffold( body: SingleChildScrollView( child: Center(child: Text(\"Chat\")), ), );을 return Scaffold( body: SingleChildScrollView( physics: BouncingScrollPhysics(), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ SafeArea( child: Padding( padding: EdgeInsets.only(left: 16,right: 16,top: 10), child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ Text(\"Conversations\",style: TextStyle(fontSize: 32,fontWeight: FontWeight.bold),), Container( padding: EdgeInsets.only(left: 8,right: 8,top: 2,bottom: 2), height: 30, decoration: BoxDecoration( borderRadius: BorderRadius.circular(30), color: Colors.pink[50], ), child: Row( children: &lt;Widget&gt;[ Icon(Icons.add,color: Colors.pink,size: 20,), SizedBox(width: 2,), Text(\"Add New\",style: TextStyle(fontSize: 14,fontWeight: FontWeight.bold),), ], ), ) ], ), ), ), ], ), ), );로 수정 body: SingleChildScrollViewchatPage 의 본문을 전체적으로 스크롤 할 수 있도록 physics: BouncingScrollPhysics()사용자의 스크롤이 끝/시작부분에 도달할 때 바운싱 효과를 내어, 끝 부분에 도달했음을 알기 쉽게 함 children: &lt; Widget &gt; [Text(), Container()]헤더를 표시할 텍스트 위젯과 컨테이너 child: ColumnSingleChildScrollView 의 모든 하위 항목은 수직으로 표시함검색창을 만들어주자Column 위젯의 내용을 변경 children:SafeArea(), 다음에Padding( padding: EdgeInsets.only(top: 16,left: 16,right: 16), child: TextField( decoration: InputDecoration( hintText: \"Search...\", hintStyle: TextStyle(color: Colors.grey.shade600), prefixIcon: Icon(Icons.search,color: Colors.grey.shade600, size: 20,), filled: true, fillColor: Colors.grey.shade100, contentPadding: EdgeInsets.all(8), enabledBorder: OutlineInputBorder( borderRadius: BorderRadius.circular(20), borderSide: BorderSide( color: Colors.grey.shade100 ) ), ), ),),를 추가여기까지의 화면대화 목록을 만들어 주자대화 목록의 인스턴스를 저장하는 클래스(객체) 모델을 먼저 만들어야 함./lib 폴더에 ./models 라는 폴더를 생성./models 안에 chatUsersModel.dart 라는 파일을 생성/lib/models/chatUsersModel.dart 파일에import 'package:flutter/cupertino.dart';class ChatUsers{ String name; String messageText; String imageURL; String time; ChatUsers({required this.name,required this.messageText,required this.imageURL,required this.time});}와 같이 ChatUsers 라는 클래스를 작성ChatUsers 객체에는 사용자 이름, 텍스트 메세지, 이미지 URL, 시간이 저장됨 원문에는 입력 받아야할 파라메터들 앞에 반드시 값이 필요하다는 의미로 @required 어노테이션(Annotation)을 사용을 하고 있는데, Flutter 2.0 부터는 null safty 문제로 requried 를 쓰도록 바뀌었다. requried을 사용하면 필수 파라메터가 들어오지 않았을 때, 빌드 시 에러를 내보낼 수 있다.그 다음 다시 /lib/screen/chatPage.dart 로 돌아와서import 'package:flt_20220703_simple_chatapp/models/chatUsersModel.dart';해주고, 방금 만든 클래스를 이용해 사용자 목록을 만들어 주자List&lt;ChatUsers&gt; chatUsers = [ ChatUsers(name: \"Jane Russel\", messageText: \"Awesome Setup\", imageURL: \"https://randomuser.me/api/portraits/men/1.jpg\", time: \"Now\"), ChatUsers(name: \"Glady's Murphy\", messageText: \"That's Great\", imageURL: \"https://randomuser.me/api/portraits/women/1.jpg\", time: \"Yesterday\"), ChatUsers(name: \"Jorge Henry\", messageText: \"Hey where are you?\", imageURL: \"https://randomuser.me/api/portraits/men/2.jpg\", time: \"31 Mar\"), ChatUsers(name: \"Philip Fox\", messageText: \"Busy! Call me in 20 mins\", imageURL: \"https://randomuser.me/api/portraits/women/2.jpg\", time: \"28 Mar\"), ChatUsers(name: \"Debra Hawkins\", messageText: \"Thankyou, It's awesome\", imageURL: \"https://randomuser.me/api/portraits/men/3.jpg\", time: \"23 Mar\"), ChatUsers(name: \"Jacob Pena\", messageText: \"will update you in evening\", imageURL: \"https://randomuser.me/api/portraits/women/3.jpg\", time: \"17 Mar\"), ChatUsers(name: \"Andrey Jones\", messageText: \"Can you please share the file?\", imageURL: \"https://randomuser.me/api/portraits/men/4.jpg\", time: \"24 Feb\"), ChatUsers(name: \"John Wick\", messageText: \"How are you?\", imageURL: \"https://randomuser.me/api/portraits/women/4.jpg\", time: \"18 Feb\"), ]; 원문에는 각각의 imageURL 에 로컬 이미지 파일 패스를 입력해 줬는데, 나는 따로 저장해 놓은 파일이 없어서 인터넷 URL 로 수정개별 대화를 위한 개별 클래스 위젯을 만들자./lib 폴더에 ./widgets 라는 폴더를 생성./models 안에 conversationList.dart 라는 파일을 생성/lib/models/conversationList.dart 파일에import 'package:flutter/material.dart';class ConversationList extends StatefulWidget{ String name; String messageText; String imageUrl; String time; bool isMessageRead; ConversationList({required this.name,required this.messageText,required this.imageUrl,required this.time,required this.isMessageRead}); @override _ConversationListState createState() =&gt; _ConversationListState();}class _ConversationListState extends State&lt;ConversationList&gt; { @override Widget build(BuildContext context) { return GestureDetector( onTap: (){ }, child: Container( padding: EdgeInsets.only(left: 16,right: 16,top: 10,bottom: 10), child: Row( children: &lt;Widget&gt;[ Expanded( child: Row( children: &lt;Widget&gt;[ CircleAvatar( backgroundImage: NetworkImage(widget.imageUrl), maxRadius: 30, ), SizedBox(width: 16,), Expanded( child: Container( color: Colors.transparent, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Text(widget.name, style: TextStyle(fontSize: 16),), SizedBox(height: 6,), Text(widget.messageText,style: TextStyle(fontSize: 13,color: Colors.grey.shade600, fontWeight: widget.isMessageRead?FontWeight.bold:FontWeight.normal),), ], ), ), ), ], ), ), Text(widget.time,style: TextStyle(fontSize: 12,fontWeight: widget.isMessageRead?FontWeight.bold:FontWeight.normal),), ], ), ), ); }}추가여기서는 chatUsersModel.dart 에 만든 객체의 변수 + 메세지 유형을 표시 할 bool 값을 파라미터로 사용하고, 그 값이 포함된 템플릿을 반환함/lib/screen/chatPage.dart 의 ListView 위젯 안에서 필요한 파라미터를 전달하여, conversationList 위젯을 호출해야 함언제나 그렇듯…먼저 임포트를 해주고import 'package:flt_20220703_simple_chatapp/widgets/conversationList.dart';Column 위젯의 내용을 변경 children:SafeArea(), Padding(), 다음에ListView.builder( itemCount: chatUsers.length, shrinkWrap: true, padding: EdgeInsets.only(top: 16), physics: NeverScrollableScrollPhysics(), itemBuilder: (context, index){ return ConversationList( name: chatUsers[index].name, messageText: chatUsers[index].messageText, imageUrl: chatUsers[index].imageURL, time: chatUsers[index].time, isMessageRead: (index == 0 || index == 3)?true:false, ); },),를 추가해 주자그리고 핫 로드를 하면 이런 화면이 된다후기dart … 처음 접하지만 라떼언어와 요즘언어의 짬뽕같은 느낌이라 둘 다 어설프게 아는 나는 오히려 받아들이기 쉬운 것 같기도 하다 다음은 채팅 세부 화면을 구현하는 내용!" }, { "title": "Kae's Dev Blog 개요", "url": "/posts/MyBlog/", "categories": "Personal, Blogging", "tags": "personal, myblogging", "date": "2022-07-01 10:37:00 +0900", "snippet": "카에입니다.개발 관련 공부나 이것저것 기록하는 용도로 사용합니다.(2022.07~)완벽한 상태에서 디플로이하는 게 아니라 포스팅 내용은 수정될 수 있습니다.대부분 모르는 것을 공부하며 작성한 글이므로 틀린 내용이 있을 수 있습니다. 알려주시면 수정하겠습니다.작성한 내용 중 원문/출처가 있는 경우 반드시 링크를 걸어 놓으니 원문을 같이 봐주세요." } ]
